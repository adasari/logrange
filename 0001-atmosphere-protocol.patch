From 6bedae739e4594c672b40639a6343ed33d8722d0 Mon Sep 17 00:00:00 2001
From: Dmitry Spasibenko <dspasibenko@gmail.com>
Date: Tue, 9 Oct 2018 11:37:36 -0700
Subject: [PATCH] atmosphere protocol

---
 .travis.yml                                    |   6 +
 README.md                                      |   2 +
 pkg/protocol/atmosphere/README.md              |  38 +++
 pkg/protocol/atmosphere/atmosphere.go          | 105 ++++++++
 pkg/protocol/atmosphere/client.go              | 204 ++++++++++++++
 pkg/protocol/atmosphere/client_server_test.go  | 341 ++++++++++++++++++++++++
 pkg/protocol/atmosphere/proto.go               |  68 +++++
 pkg/protocol/atmosphere/server.go              | 354 +++++++++++++++++++++++++
 pkg/protocol/atmosphere/stream.go              | 163 ++++++++++++
 pkg/protocol/atmosphere/test_certs/README.md   |   1 +
 pkg/protocol/atmosphere/test_certs/chain.pem   |  46 ++++
 pkg/protocol/atmosphere/test_certs/client.crt  |  87 ++++++
 pkg/protocol/atmosphere/test_certs/client.key  |  28 ++
 pkg/protocol/atmosphere/test_certs/client0.crt |  87 ++++++
 pkg/protocol/atmosphere/test_certs/client0.key |  28 ++
 pkg/protocol/atmosphere/test_certs/server.crt  |  87 ++++++
 pkg/protocol/atmosphere/test_certs/server.key  |  28 ++
 pkg/protocol/atmosphere/test_certs/server0.crt |  85 ++++++
 pkg/protocol/atmosphere/test_certs/server0.key |  28 ++
 pkg/protocol/atmosphere/transport.go           | 163 ++++++++++++
 pkg/protocol/atmosphere/transport_test.go      | 103 +++++++
 pkg/util/hash/hash.go                          | 130 +++++++++
 pkg/util/hash/hash_test.go                     |  37 +++
 23 files changed, 2219 insertions(+)
 create mode 100644 .travis.yml
 create mode 100644 pkg/protocol/atmosphere/README.md
 create mode 100644 pkg/protocol/atmosphere/atmosphere.go
 create mode 100644 pkg/protocol/atmosphere/client.go
 create mode 100644 pkg/protocol/atmosphere/client_server_test.go
 create mode 100644 pkg/protocol/atmosphere/proto.go
 create mode 100644 pkg/protocol/atmosphere/server.go
 create mode 100644 pkg/protocol/atmosphere/stream.go
 create mode 100644 pkg/protocol/atmosphere/test_certs/README.md
 create mode 100644 pkg/protocol/atmosphere/test_certs/chain.pem
 create mode 100644 pkg/protocol/atmosphere/test_certs/client.crt
 create mode 100644 pkg/protocol/atmosphere/test_certs/client.key
 create mode 100644 pkg/protocol/atmosphere/test_certs/client0.crt
 create mode 100644 pkg/protocol/atmosphere/test_certs/client0.key
 create mode 100644 pkg/protocol/atmosphere/test_certs/server.crt
 create mode 100644 pkg/protocol/atmosphere/test_certs/server.key
 create mode 100644 pkg/protocol/atmosphere/test_certs/server0.crt
 create mode 100644 pkg/protocol/atmosphere/test_certs/server0.key
 create mode 100644 pkg/protocol/atmosphere/transport.go
 create mode 100644 pkg/protocol/atmosphere/transport_test.go
 create mode 100644 pkg/util/hash/hash.go
 create mode 100644 pkg/util/hash/hash_test.go

diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 0000000..7794c8f
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,6 @@
+language: go
+go:
+ - 1.11.x
+
+script:
+ - go test -v ./...
diff --git a/README.md b/README.md
index 308fb2c..1f13bcf 100644
--- a/README.md
+++ b/README.md
@@ -1,2 +1,4 @@
+[![Go Report Card](https://goreportcard.com/badge/logrange/logrange)](https://goreportcard.com/report/logrange/logrange) [![Build Status](https://travis-ci.org/logrange/logrange.svg?branch=master)](https://travis-ci.org/logrange/logrange) [![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://github.com/logrange/logrange/blob/master/LICENSE)
+
 # logrange
 
diff --git a/pkg/protocol/atmosphere/README.md b/pkg/protocol/atmosphere/README.md
new file mode 100644
index 0000000..d25edb5
--- /dev/null
+++ b/pkg/protocol/atmosphere/README.md
@@ -0,0 +1,38 @@
+# atmosphere - a simple log transport protocol
+atmosphere is simple _synchronous request-response_ protocol for sending log data to an aggregation server. The _synchronous request-response_ term means that client will not send new data until it receives and recognizes response from server on its previous request.
+
+Every wire message in both directions Client->Server or Server->Client is reprsented by the following format:
+* data size (4 bytes) - 31 bit is used, so maximum payload size is 2Gib
+* packet type (2 bytes) - 2 values are known 1 - _Auth_ packet, 2 - _Data_ packet
+* data (various size) - data which is sent. Could be 0 length
+
+There are 2 phases in Client-Server communication:
+* Authentication
+* Data exchange
+
+## Authentication 
+After connection with client server expects the client authentication. Only _Auth_ packets are accepted. Payload must be json in the following form:
+```
+{
+    "ak": "testClient",
+    "sk": "4xEp17eOvDzz1rjnjcWx4ay",
+}
+```
+If server recognizes access-secret keys pair (ak, sk values), it responds by the following json in _Auth_ packet response:
+```
+{
+    "sessId": "12384987349137249123749128374",
+    "terminal": false
+}
+```
+if the authentication was wrong, it will respond with json packet where `"terminal": true` and an explanation in `info` field. In case of failed authentication the server will close the connection shortly after the response.
+
+## Data exchange
+All data is sent using _Data_ packet type, which are acceptable for clients that passed authentication successfully. If a non-authenticated client sends the _Data_ packet the server will close the connection immediately. Any client's packet must be confirmed (even with 0 lenght response) by the server. So until client receives response on its packet, it cannot send next packet.
+
+### Heart Beat
+Heart beat is an authentication packet sent by Client to the server to let the server know, that client is alive. Server configuration can dictate to close connection in case of no _Auth_ packet from client is received for some period of time. Client should use session Id received from server while authentication process was run. New session id can be issued, so next time client has to use it.
+
+# Examples
+TBD.
+
diff --git a/pkg/protocol/atmosphere/atmosphere.go b/pkg/protocol/atmosphere/atmosphere.go
new file mode 100644
index 0000000..d10747d
--- /dev/null
+++ b/pkg/protocol/atmosphere/atmosphere.go
@@ -0,0 +1,105 @@
+package atmosphere
+
+import (
+	"errors"
+)
+
+type (
+	// Used for configuring writer (client)
+	ClientConfig struct {
+
+		// heartbeat timeout in milliseconds. If set to 0 then no heartbeat
+		// will be sent. Values less than several seconds must be used for
+		// tests only. Recommended value is 10 seconds
+		HeartBeatMs int
+
+		// Access key for the client authentication
+		AccessKey string
+
+		// Secret key for the client authentication
+		SecretKey string
+
+		TransportConfig
+	}
+
+	Message []byte
+
+	// Writer interface is used by clients to send data to the server
+	Writer interface {
+		// Write sends the message m to the server. Server can respond by a buffer
+		// the size of the response is returned in first parameter n, which can be 0.
+		// if len(rm) >= n, then the result is stored into rm, otherwise, just
+		// the size is returned.
+		//
+		// If any error happens it is returned in the error and considered like
+		// situation when the client cannot be used anymore.
+		Write(m Message, rm Message) (int, error)
+
+		Close() error
+	}
+
+	// ServerConfig is used for provide configuration to atmosphere server
+	ServerConfig struct {
+		// For network transports like TCP and TLS provides the addrees where
+		// it will be listening on.
+		ListenAddress string
+
+		// SessTimeoutMs defines client's session timeout in milliseconds. Server
+		// will close all connections who's sessions are not updated for the
+		// period of time. If 0, then no timeout is applied. Small values
+		// must be used for testing only. Recommended is 30000ms (30sec)
+		SessTimeoutMs int
+
+		// ConnListener defines a listener for requests coming from a server
+		// connection. See ServerListener.
+		ConnListener ServerListener
+
+		// Auth an authenitcation function used by server to authenticate
+		// client Auth requests.
+		Auth AuthFunc
+
+		TransportConfig
+	}
+
+	// Reader used by server to read messages sent by a client. Read and ReadResponse
+	// are 2 functions which should be used to read the client message. They are
+	// not concurrent and it is user responsibility to not call them from different
+	// go routines
+	Reader interface {
+		// Read put bytes which were sent by client into buf. The method returns
+		// number of bytes were actually read. The number can be less than reported
+		// in OnRead call. This case the Read operation should be repeated until
+		// all data is read. When all bytes were read the client must call
+		// ReadResponse() to send response back to the client.
+		Read(buf []byte) (int, error)
+
+		// ReadResponse closes the reading process of the client's packet. It can be called
+		// before Read() operation read all bytes reported in OnRead() operation.
+		// This case the rest bytes will be dropped from the stream and lost forewer.
+		//
+		// After calling ReadResponse() the Read() may be called only after next
+		// OnRead() notification. Violating the rule can broke the connection.
+		ReadResponse(resp []byte) error
+		Close() error
+	}
+
+	// ServerListener registers for the server events
+	ServerListener interface {
+
+		// OnRead invoked by atmosphere server to notify listener about a new packet
+		// Listener should perform read procedure then following the Reader
+		// agreements
+		OnRead(r Reader, n int) error
+	}
+
+	// AuthFunc is used by server for authentication a client by akey and skey
+	// It returns true if aKey and the sKey are knwon and matched
+	AuthFunc func(aKey, sKey string) bool
+)
+
+var (
+	ErrInvalidState = errors.New("the state doesn't allow the operation")
+	ErrCannotWrite  = errors.New("cannot perform write, wrong state")
+	ErrCannotRead   = errors.New("cannot perform read, wrong state or data unavailable")
+	ErrStreamBroken = errors.New("unexpected value is received")
+)
diff --git a/pkg/protocol/atmosphere/client.go b/pkg/protocol/atmosphere/client.go
new file mode 100644
index 0000000..a32409f
--- /dev/null
+++ b/pkg/protocol/atmosphere/client.go
@@ -0,0 +1,204 @@
+package atmosphere
+
+import (
+	"context"
+	"io"
+	"sync"
+	"time"
+
+	"github.com/jrivets/log4g"
+)
+
+type (
+	client struct {
+		cfg       ClientConfig
+		strm      stream
+		lock      sync.Mutex
+		cond      *sync.Cond
+		state     int
+		writers   int
+		sessId    string
+		ctxCancel context.CancelFunc
+		ctx       context.Context
+		logger    log4g.Logger
+	}
+)
+
+const (
+	csAuthenticating = iota
+	csReady
+	csWriting
+	csClosed
+)
+
+func newClient(ccfg *ClientConfig, rwc io.ReadWriteCloser) *client {
+	c := new(client)
+	c.cfg = *ccfg
+	c.cond = sync.NewCond(&c.lock)
+	c.state = csAuthenticating
+	c.logger = log4g.GetLogger("atmosphere.client")
+	c.ctx, c.ctxCancel = context.WithCancel(context.Background())
+	c.strm.rwc = rwc
+	c.strm.logger = log4g.GetLogger("atmosphere.client.strm")
+	go c.authenticate()
+	return c
+}
+
+func (c *client) Write(m Message, rm Message) (int, error) {
+	err := c.acquireWriter()
+	if err != nil {
+		return 0, err
+	}
+
+	err = c.strm.writeBuf(ptMessage, m)
+	if err != nil {
+		c.Close()
+		c.releaseWriter()
+		return 0, err
+	}
+
+	tp, n, err := c.strm.readHeader()
+	if err != nil || tp != ptMessage {
+		c.Close()
+		c.releaseWriter()
+		return 0, err
+	}
+
+	err = c.strm.readOrSkip(n, rm)
+	c.releaseWriter()
+	return n, err
+}
+
+func (c *client) Close() error {
+	c.lock.Lock()
+	defer c.lock.Unlock()
+
+	var err error
+	if c.state != csClosed {
+		c.logger.Info("Closing the client")
+		c.state = csClosed
+		c.ctxCancel()
+		c.cond.Broadcast()
+		err = c.strm.close()
+	}
+	return err
+}
+
+// ------------------------- the client internals ----------------------------
+func (c *client) authenticate() {
+	c.logger.Info("Authenticating...")
+	ar, err := c.strm.authHandshake(&AuthReq{AccessKey: strPtr(c.cfg.AccessKey), SecretKey: strPtr(c.cfg.SecretKey)})
+	if err != nil {
+		c.logger.Error("authenticate(): Could not write auth request, err=", err)
+		c.Close()
+		return
+	}
+
+	c.logger.Info("authenticate(): Response ", ar.String())
+	sid := strFromPtr(ar.SessionId)
+	if ar.Terminal || len(sid) == 0 {
+		c.logger.Warn("authenticate(): Got terminal response, or empty session id")
+		c.Close()
+		return
+	}
+
+	c.lock.Lock()
+	defer c.lock.Unlock()
+	if c.state != csAuthenticating {
+		c.logger.Warn("Could not complete authentication, state is changed ")
+		return
+	}
+
+	c.state = csReady
+	c.sessId = strFromPtr(ar.SessionId)
+	c.logger.Debug("Switching to csReady c.writers=", c.writers)
+	if c.writers > 0 {
+		c.cond.Signal()
+	}
+
+	go c.heartBeat()
+}
+
+// getSessionId gets current session id, for test purposes only
+func (c *client) getSessionId() string {
+	c.acquireWriter()
+	defer c.releaseWriter()
+	return c.sessId
+}
+
+func (c *client) heartBeat() {
+	to := time.Duration(c.cfg.HeartBeatMs) * time.Millisecond
+	if to == 0 {
+		c.logger.Warn("No heartbeat. Timeout is 0")
+		return
+	}
+	c.logger.Info("Will send heartbeat every ", c.cfg.HeartBeatMs, "ms")
+	defer c.logger.Info("Heartbeat is over")
+	for {
+		select {
+		case <-time.After(to):
+			if !c.sendHeartBeat() {
+				return
+			}
+		case <-c.ctx.Done():
+			return
+		}
+	}
+}
+
+func (c *client) sendHeartBeat() bool {
+	err := c.acquireWriter()
+	if err != nil {
+		c.Close()
+		return false
+	}
+	defer c.releaseWriter()
+
+	ar, err := c.strm.authHandshake(&AuthReq{SessionId: strPtr(c.sessId)})
+	if err != nil {
+		c.Close()
+		return false
+	}
+
+	c.logger.Debug("sendHeartBeat(): Response ", &ar)
+	sid := strFromPtr(ar.SessionId)
+	if ar.Terminal {
+		c.logger.Warn("sendHeartBeat(): Got terminal response ", &ar)
+		c.Close()
+		return false
+	}
+
+	c.sessId = sid
+	return true
+}
+
+func (c *client) acquireWriter() error {
+	c.logger.Trace("acquireWriter()")
+	c.lock.Lock()
+	for c.state == csWriting || c.state == csAuthenticating {
+		c.writers++
+		c.cond.Wait()
+		c.writers--
+	}
+	c.logger.Trace("acquireWriter(): awaken")
+
+	var err error
+	if c.state == csReady {
+		c.state = csWriting
+	} else {
+		err = ErrCannotWrite
+	}
+	c.lock.Unlock()
+	return err
+}
+
+func (c *client) releaseWriter() {
+	c.lock.Lock()
+	if c.state == csWriting {
+		if c.writers > 0 {
+			c.cond.Signal()
+		}
+		c.state = csReady
+	}
+	c.lock.Unlock()
+}
diff --git a/pkg/protocol/atmosphere/client_server_test.go b/pkg/protocol/atmosphere/client_server_test.go
new file mode 100644
index 0000000..c67ab22
--- /dev/null
+++ b/pkg/protocol/atmosphere/client_server_test.go
@@ -0,0 +1,341 @@
+package atmosphere
+
+import (
+	"crypto/tls"
+	"errors"
+	"fmt"
+	"path/filepath"
+	"runtime"
+	"sync"
+	"testing"
+	"time"
+
+	"github.com/jrivets/log4g"
+)
+
+type testReader struct {
+	n  int
+	to time.Duration
+}
+
+func (tr *testReader) OnRead(r Reader, n int) error {
+	log := log4g.GetLogger("testReader")
+	log.Info("OnRead(): n=", n)
+	b := make([]byte, n)
+	for n > 0 {
+		ln, err := r.Read(b)
+		if err != nil {
+			r.ReadResponse(nil)
+			return err
+		}
+		n -= ln
+	}
+	if tr.to > 0 {
+		time.Sleep(tr.to)
+	}
+	r.ReadResponse(b)
+	return nil
+}
+
+func newTestReader() *testReader {
+	tr := new(testReader)
+	return tr
+}
+
+func TestReadWrite(t *testing.T) {
+	_, d, _, _ := runtime.Caller(0)
+	crtsDir := filepath.Dir(d) + "/test_certs/"
+
+	log4g.SetLogLevel("", log4g.INFO)
+	tr := newTestReader()
+	scfg := &ServerConfig{ListenAddress: ":12345", ConnListener: tr, Auth: func(aKey, sKey string) bool { return true }}
+	scfg.Tls = true
+	scfg.TransportConfig.LoadX509Files(crtsDir+"server0.crt", crtsDir+"server0.key", "")
+	// one-way TLS
+	scfg.ClientAuthType = tls.NoClientCert
+
+	srv, err := NewServer(scfg)
+	if srv == nil || err != nil {
+		t.Fatal("should create srv ok err=", err)
+	}
+	defer srv.Close()
+
+	msg := "Hello test"
+	ccfg := &ClientConfig{AccessKey: "test"}
+	ccfg.Tls = true
+	ccfg.TransportConfig.LoadX509Files(crtsDir+"client0.crt", crtsDir+"client0.key", crtsDir+"chain.pem")
+	cl, err := NewClient("127.0.0.1:12345", ccfg)
+	if cl == nil || err != nil {
+		t.Fatal("Expecting client be created ok")
+	}
+	defer cl.Close()
+
+	var buf [64]byte
+	n, err := cl.Write(Message(msg), Message(buf[:]))
+	if n <= 0 || err != nil {
+		t.Fatal("expected not nil response and no error")
+	}
+	resp := string(buf[:n])
+	if resp != msg {
+		t.Fatal("Expected msg=", msg, ", but received resp=", resp)
+	}
+}
+
+func TestConcurrentWrite(t *testing.T) {
+	tr := newTestReader()
+	scfg := &ServerConfig{ListenAddress: ":12350", ConnListener: tr, Auth: func(aKey, sKey string) bool { return true }}
+	srv, err := NewServer(scfg)
+	if srv == nil || err != nil {
+		t.Fatal("should create srv ok err=", err)
+	}
+	defer srv.Close()
+
+	cl, err := NewClient("127.0.0.1:12350", &ClientConfig{AccessKey: "test"})
+	if cl == nil || err != nil {
+		t.Fatal("Expecting client be created ok")
+	}
+	defer cl.Close()
+
+	log := log4g.GetLogger("TestConcurrentWrite")
+	var wg sync.WaitGroup
+	ech := make(chan error, 10)
+	for i := 0; i < 10; i++ {
+		wg.Add(1)
+		go func(i int) {
+			defer wg.Done()
+			var buf [64]byte
+			msg := fmt.Sprint("msg", i)
+			n, err := cl.Write(Message(msg), Message(buf[:]))
+			resp := string(buf[:n])
+			log.Info("Sending ", msg, " received ", n, " bytes, resp=", resp, " err=", err)
+			if err != nil {
+				ech <- err
+			}
+			if resp != msg {
+				ech <- errors.New("read " + resp + " expected " + msg)
+			}
+		}(i)
+	}
+
+	wg.Wait()
+	close(ech)
+	err, _ = <-ech
+	if err != nil {
+		t.Fatal("expecting no error ", err)
+	}
+}
+
+func TestWrongAuth(t *testing.T) {
+	time.Sleep(100)
+	tr := newTestReader()
+	scfg := &ServerConfig{ListenAddress: ":12351", ConnListener: tr, Auth: func(aKey, sKey string) bool { return false }}
+	srv, err := NewServer(scfg)
+	if srv == nil || err != nil {
+		t.Fatal("should create srv ok err=", err)
+	}
+	defer srv.Close()
+
+	cl, err := NewClient("127.0.0.1:12351", &ClientConfig{AccessKey: "test"})
+	if cl == nil || err != nil {
+		t.Fatal("Expecting client be created ok")
+	}
+	defer cl.Close()
+
+	n, err := cl.Write(Message("test"), nil)
+	if n > 0 || err == nil {
+		t.Fatal("expected not authenticated")
+	}
+	t.Log("err=", err)
+}
+
+func TestHeartbeat(t *testing.T) {
+	// if broken, uncomment and watch what is going on
+	//	log4g.SetLogLevel("", log4g.TRACE)
+	//	defer log4g.SetLogLevel("", log4g.INFO)
+	tr := newTestReader()
+	scfg := &ServerConfig{ListenAddress: ":12346", ConnListener: tr, Auth: func(aKey, sKey string) bool { return true }}
+	srv, err := NewServer(scfg)
+	if srv == nil || err != nil {
+		t.Fatal("should create srv ok err=", err)
+	}
+	defer srv.Close()
+
+	w, err := NewClient("127.0.0.1:12346", &ClientConfig{AccessKey: "test", HeartBeatMs: 1})
+	if w == nil || err != nil {
+		t.Fatal("Expecting client be created ok")
+	}
+	cl := w.(*client)
+	defer cl.Close()
+
+	start := time.Now()
+	cnt := 0
+	sid := cl.getSessionId()
+	for time.Now().Sub(start) < 100*time.Millisecond && cnt < 5 {
+		time.Sleep(time.Millisecond)
+		sid2 := cl.getSessionId()
+		if sid2 != sid {
+			sid = sid2
+			cnt++
+		}
+	}
+
+	if cnt < 5 {
+		t.Fatal("Expecting heartbeating ")
+	}
+}
+
+func TestClosedClientInTransaction(t *testing.T) {
+	tr := newTestReader()
+	tr.to = time.Second
+	scfg := &ServerConfig{ListenAddress: ":12345", ConnListener: tr, Auth: func(aKey, sKey string) bool { return true }}
+	srv, err := NewServer(scfg)
+	if srv == nil || err != nil {
+		t.Fatal("should create srv ok err=", err)
+	}
+	defer srv.Close()
+
+	msg := "Hello test"
+	cl, err := NewClient("127.0.0.1:12345", &ClientConfig{AccessKey: "test"})
+	if cl == nil || err != nil {
+		t.Fatal("Expecting client be created ok")
+	}
+	defer cl.Close()
+	go func() {
+		time.Sleep(10 * time.Millisecond)
+		cl.Close()
+	}()
+	n, err := cl.Write(Message(msg), nil)
+	if err == nil {
+		t.Fatal("expected an error, but read n=", n)
+	}
+	t.Log(err)
+}
+
+func TestClosedServerInTransaction(t *testing.T) {
+	tr := newTestReader()
+	tr.to = time.Second
+	scfg := &ServerConfig{ListenAddress: ":12347", ConnListener: tr, Auth: func(aKey, sKey string) bool { return true }}
+	srv, err := NewServer(scfg)
+	if srv == nil || err != nil {
+		t.Fatal("should create srv ok err=", err)
+	}
+	defer srv.Close()
+
+	msg := "Hello test"
+	cl, err := NewClient("127.0.0.1:12347", &ClientConfig{AccessKey: "test"})
+	if cl == nil || err != nil {
+		t.Fatal("Expecting client be created ok")
+	}
+	defer cl.Close()
+	go func() {
+		time.Sleep(10 * time.Millisecond)
+		srv.Close()
+	}()
+	n, err := cl.Write(Message(msg), nil)
+	if err == nil {
+		t.Fatal("expected an error, but read n=", n)
+	}
+	t.Log(err)
+}
+
+func TestServerShutdown(t *testing.T) {
+	tr := newTestReader()
+	tr.to = time.Second
+	scfg := &ServerConfig{ListenAddress: ":12348", ConnListener: tr, Auth: func(aKey, sKey string) bool { return true }}
+	srv, err := NewServer(scfg)
+	if srv == nil || err != nil {
+		t.Fatal("should create srv ok err=", err)
+	}
+	defer srv.Close()
+
+	for i := 0; i < 10; i++ {
+		cl, err := NewClient("127.0.0.1:12348", &ClientConfig{AccessKey: "test"})
+		if cl == nil || err != nil {
+			t.Fatal("Expecting client be created ok")
+		}
+		defer cl.Close()
+	}
+	s := srv.(*tcp_server)
+	start := time.Now()
+	for s.srv.clientsCount() < 10 && time.Now().Sub(start) < 50*time.Millisecond {
+		time.Sleep(time.Millisecond)
+	}
+	if s.srv.clientsCount() < 10 {
+		t.Fatal("Expecting 10 clients, but ", s.srv.clientsCount())
+	}
+
+	s.Close()
+	for s.srv.clientsCount() > 0 && time.Now().Sub(start) < 100*time.Millisecond {
+		time.Sleep(time.Millisecond)
+	}
+
+	if s.srv.clientsCount() > 0 {
+		t.Fatal("Expecting 0 clients, but ", s.srv.clientsCount())
+	}
+}
+
+func TestServerSessTimeout(t *testing.T) {
+	tr := newTestReader()
+	tr.to = time.Second
+	scfg := &ServerConfig{ListenAddress: ":12345", SessTimeoutMs: 50, ConnListener: tr, Auth: func(aKey, sKey string) bool { return true }}
+	srv, err := NewServer(scfg)
+	if srv == nil || err != nil {
+		t.Fatal("should create srv ok err=", err)
+	}
+	defer srv.Close()
+
+	cl, err := NewClient("127.0.0.1:12345", &ClientConfig{AccessKey: "test"})
+	if cl == nil || err != nil {
+		t.Fatal("Expecting client be created ok")
+	}
+	defer cl.Close()
+
+	s := srv.(*tcp_server)
+	start := time.Now()
+	for s.srv.clientsCount() == 0 && time.Now().Sub(start) < 25*time.Millisecond {
+		time.Sleep(time.Millisecond)
+	}
+	if s.srv.clientsCount() != 1 {
+		t.Fatal("Expecting 1 client, but ", s.srv.clientsCount())
+	}
+
+	for s.srv.clientsCount() == 1 && time.Now().Sub(start) < 200*time.Millisecond {
+		time.Sleep(time.Millisecond)
+	}
+	if s.srv.clientsCount() != 0 {
+		t.Fatal("Expecting 0 client, but ", s.srv.clientsCount())
+	}
+}
+
+func TestServerSessTimeoutVsHeartbeat(t *testing.T) {
+	tr := newTestReader()
+	tr.to = time.Second
+	scfg := &ServerConfig{ListenAddress: ":12346", SessTimeoutMs: 50, ConnListener: tr, Auth: func(aKey, sKey string) bool { return true }}
+	srv, err := NewServer(scfg)
+	if srv == nil || err != nil {
+		t.Fatal("should create srv ok err=", err)
+	}
+	defer srv.Close()
+
+	cl, err := NewClient("127.0.0.1:12346", &ClientConfig{AccessKey: "test", HeartBeatMs: 10})
+	if cl == nil || err != nil {
+		t.Fatal("Expecting client be created ok")
+	}
+	defer cl.Close()
+
+	s := srv.(*tcp_server)
+	start := time.Now()
+	for s.srv.clientsCount() == 0 && time.Now().Sub(start) < 25*time.Millisecond {
+		time.Sleep(time.Millisecond)
+	}
+	if s.srv.clientsCount() != 1 {
+		t.Fatal("Expecting 1 client, but ", s.srv.clientsCount())
+	}
+
+	for s.srv.clientsCount() == 1 && time.Now().Sub(start) < 200*time.Millisecond {
+		time.Sleep(time.Millisecond)
+	}
+	if s.srv.clientsCount() != 1 {
+		t.Fatal("Expecting 1 client, but ", s.srv.clientsCount())
+	}
+}
diff --git a/pkg/protocol/atmosphere/proto.go b/pkg/protocol/atmosphere/proto.go
new file mode 100644
index 0000000..4c671f1
--- /dev/null
+++ b/pkg/protocol/atmosphere/proto.go
@@ -0,0 +1,68 @@
+// atmosphere package provides implementation for simple client-server protocol
+// for sending log data to an aggregation server.
+package atmosphere
+
+import (
+	"fmt"
+)
+
+type (
+	// AuthReq is sent by client with ptAuth, to request authentication. The same
+	// message is used by client for sending heartbeat, using session id instead
+	// of keys.
+	AuthReq struct {
+		// AccessKey contains the access key for the authentication. It could be nil
+		// or empty in case of sessionId is provided
+		AccessKey *string `json:"ak,omitempty"`
+
+		// SecretKey contains the secret key for the authentication. It could be nil
+		// or empty in case of sessionId is provided
+		SecretKey *string `json:"sk,omitempty"`
+
+		// SessionId contains a session id for provide the authentication.
+		// This method is used for sending a hearbeat
+		SessionId *string `json:"sessId,omitempty"`
+	}
+
+	// AuthResp is a response sent by server back to the client as a response
+	// to AuthReq.
+	AuthResp struct {
+		// SessionId contains session id that should be used for heartbeats
+		SessionId *string `json:"sessId,omitempty"`
+
+		// Terminal contains whether the client can perform attempts for authentication
+		// or not. If the field is true, client must close the connection and
+		// reopen it with other params. Server will close the connection soon, if
+		// client will not do this.
+		Terminal bool `json:"terminal"`
+
+		// Informational message regarding the authentication problem
+		Info *string `json:"info,omitempty"`
+	}
+)
+
+var (
+	ptAuth    = 1
+	ptMessage = 2
+)
+
+func strPtr(s string) *string {
+	return &s
+}
+
+func strFromPtr(ps *string) string {
+	if ps == nil {
+		return ""
+	}
+	return *ps
+}
+
+func (ar *AuthResp) String() string {
+	return fmt.Sprint("{SessionId=", strFromPtr(ar.SessionId), ", Terminal=", ar.Terminal,
+		", Info=", strFromPtr(ar.Info), "}")
+}
+
+func (ar *AuthReq) String() string {
+	return fmt.Sprint("{AccessKey=", strFromPtr(ar.AccessKey), ", SecretKey=", len(strFromPtr(ar.SecretKey)),
+		", SessionId=", strFromPtr(ar.SessionId), "}")
+}
diff --git a/pkg/protocol/atmosphere/server.go b/pkg/protocol/atmosphere/server.go
new file mode 100644
index 0000000..e075fc2
--- /dev/null
+++ b/pkg/protocol/atmosphere/server.go
@@ -0,0 +1,354 @@
+package atmosphere
+
+import (
+	"context"
+	"fmt"
+	"io"
+	"math"
+	"strconv"
+	"sync"
+	"time"
+
+	"github.com/jrivets/log4g"
+	"github.com/logrange/logrange/pkg/collection"
+	"github.com/logrange/logrange/pkg/util/hash"
+)
+
+type (
+	server struct {
+		lock sync.Mutex
+		// const - used by multiple go routines
+		scfg      ServerConfig
+		ctx       context.Context
+		ctxCancel context.CancelFunc
+		clients   *collection.Lru
+		sessions  map[int]string
+		idCnt     int
+		logger    log4g.Logger
+	}
+
+	serverClient struct {
+		id       int
+		lock     sync.Mutex
+		cond     *sync.Cond
+		state    int
+		srv      *server
+		strm     stream
+		clntRead int
+		logger   log4g.Logger
+	}
+)
+
+const (
+	scsWatching = iota
+	scsReading
+	scsClosed
+)
+
+// ------------------------------ server -------------------------------------
+func newServer(scfg *ServerConfig) *server {
+	s := new(server)
+	s.scfg = *scfg
+	s.ctx, s.ctxCancel = context.WithCancel(context.Background())
+	s.logger = log4g.GetLogger("atmosphere.server")
+	s.sessions = make(map[int]string)
+
+	// configuring connection timeout
+	clnupTimeout := time.Duration(scfg.SessTimeoutMs) * time.Millisecond
+	s.clients = collection.NewLru(math.MaxInt64, clnupTimeout, s.onDeleteFromCache)
+	if clnupTimeout <= 0 {
+		clnupTimeout = time.Duration(math.MaxInt64)
+	}
+
+	go func() {
+		for s.ctx.Err() == nil {
+			select {
+			case <-s.ctx.Done():
+				break
+			case <-time.After(clnupTimeout):
+				s.connCleanup()
+			}
+		}
+
+		s.logger.Info("Shutting down, context closed, s.ctx.Err()=", s.ctx.Err())
+		s.lock.Lock()
+		clnts := make([]*serverClient, 0, s.clients.Len())
+		s.clients.Iterate(func(k, v interface{}) bool {
+			clnts = append(clnts, v.(*serverClient))
+			return true
+		})
+		s.lock.Unlock()
+
+		// Close all known clients now, without lock
+		for _, sc := range clnts {
+			sc.Close()
+		}
+	}()
+	return s
+}
+
+func (s *server) Serve(conn io.ReadWriteCloser) error {
+	s.lock.Lock()
+	defer s.lock.Unlock()
+
+	s.logger.Debug("New Connection ", conn)
+	if s.ctx.Err() != nil {
+		return ErrInvalidState
+	}
+	s.idCnt++
+	sc := newServerClient(s, conn, s.idCnt)
+	s.clients.Put(s.idCnt, sc, 1)
+	return nil
+}
+
+func (s *server) Close() error {
+	s.logger.Info("Closing")
+	s.ctxCancel()
+	return nil
+}
+
+// called by serverClient holding its own lock, so never come back for avoiding
+// deadlock
+func (s *server) onClose(sc *serverClient) {
+	s.lock.Lock()
+	defer s.lock.Unlock()
+
+	s.logger.Debug("server client ", sc.id, " closed notification")
+	s.clients.DeleteNoCallback(sc.id)
+	delete(s.sessions, sc.id)
+}
+
+// called by serverClient holding its own lock, so never come back for avoiding
+// deadlock
+func (s *server) authenticate(sc *serverClient, ar *AuthReq) string {
+	ak := strFromPtr(ar.AccessKey)
+	sessId := strFromPtr(ar.SessionId)
+	if len(sessId) == 0 && !s.scfg.Auth(ak, strFromPtr(ar.SecretKey)) {
+		s.logger.Warn("Rejecting ", sc, " wrong authentication request ", &ar)
+		return ""
+	}
+
+	s.lock.Lock()
+	defer s.lock.Unlock()
+
+	// this Get() call will refresh position in the LRU cache
+	val := s.clients.Get(sc.id)
+	if val == nil {
+		s.logger.Warn("Rejecting ", sc, " unknown client, may be already closed concurrently? ", ar)
+		return ""
+	}
+
+	sid, ok := s.sessions[sc.id]
+	if len(sessId) > 0 && (!ok || sessId != sid) {
+		delete(s.sessions, sc.id)
+		s.logger.Warn("Rejecting ", sc, " unknown session, or authentication request ", ar)
+		return ""
+	}
+	sid = hash.NewSession(48)
+	s.sessions[sc.id] = sid
+	return sid
+}
+
+func (s *server) connCleanup() {
+	if s.scfg.SessTimeoutMs <= 0 {
+		s.logger.Warn("Session cleanup is turned off, but called. Ignore.")
+		return
+	}
+
+	s.clients.SweepByTime()
+}
+
+// onDeleteFromCache clients Lru callback. Called by container when a client
+// is pulled out by session timeout
+func (s *server) onDeleteFromCache(k, v interface{}) {
+	sc, ok := v.(*serverClient)
+	if ok {
+		s.logger.Warn("Closing connection by timeout (no heartbeating) ", sc)
+		// this notification is called under lock, don't make a deadlock - call
+		// the client close in another go-routine
+		go sc.Close()
+	}
+}
+
+// used for test purposes
+func (s *server) clientsCount() int {
+	s.lock.Lock()
+	defer s.lock.Unlock()
+
+	return s.clients.Len()
+}
+
+func (s *server) String() string {
+	return fmt.Sprint("{idCnt=", s.idCnt, ", clients=", s.clients.Len(), "}")
+}
+
+// --------------------------- serverClient ---------------------------------
+func newServerClient(srv *server, rwc io.ReadWriteCloser, id int) *serverClient {
+	sc := new(serverClient)
+	sc.id = id
+	sc.srv = srv
+	sc.cond = sync.NewCond(&sc.lock)
+	sc.state = scsWatching
+	sc.logger = log4g.GetLogger("atmosphere.serverClient").WithId("{" + strconv.Itoa(id) + "}").(log4g.Logger)
+	sc.strm.rwc = rwc
+	sc.strm.logger = log4g.GetLogger("atmosphere.serverClient.strm").WithId("{" + strconv.Itoa(id) + "}").(log4g.Logger)
+	go sc.watcher()
+	return sc
+}
+
+func (sc *serverClient) String() string {
+	return fmt.Sprint("{id=", sc.id, ", state=", sc.state, "}")
+}
+
+func (sc *serverClient) Read(buf []byte) (int, error) {
+	sc.lock.Lock()
+	if sc.state != scsReading {
+		sc.logger.Warn("Read is called in state=", sc.state,
+			", expecting scsReading(", scsReading, ")")
+		return 0, ErrCannotRead
+	}
+	n := sc.clntRead
+	sc.lock.Unlock()
+
+	sc.logger.Trace("Read(): n=", n, ", len(buf)=", len(buf))
+	if n > len(buf) {
+		n = len(buf)
+	}
+	n, err := io.ReadFull(sc.strm.rwc, buf[:n])
+	sc.clntRead -= n
+	if err != nil {
+		sc.logger.Warn("Error in a middle of reading client message, err=", err)
+		sc.Close()
+	}
+
+	return n, err
+}
+
+// ReadResponse must be called from the client listener from OnRead() notification
+// so it is part of the reading message process.
+func (sc *serverClient) ReadResponse(resp []byte) error {
+	sc.lock.Lock()
+	if sc.state != scsReading {
+		sc.logger.Warn("ReadResponse is called in state=", sc.state,
+			", expecting scsReading(", scsReading, ")")
+		return ErrCannotRead
+	}
+	skip := sc.clntRead
+	sc.clntRead = 0
+	sc.lock.Unlock()
+
+	sc.strm.readOrSkip(skip, nil)
+	err := sc.strm.writeBuf(ptMessage, resp)
+
+	sc.lock.Lock()
+	if sc.state == scsReading {
+		sc.state = scsWatching
+		sc.cond.Signal()
+	}
+
+	if err != nil {
+		sc.logger.Warn("Error in wrtiting reading response to client, err=", err)
+		sc.close()
+	}
+	sc.lock.Unlock()
+	return err
+}
+
+func (sc *serverClient) Close() error {
+	sc.lock.Lock()
+	defer sc.lock.Unlock()
+
+	return sc.close()
+}
+
+func (sc *serverClient) close() error {
+	var err error
+	if sc.state != scsClosed {
+		sc.state = scsClosed
+		sc.cond.Broadcast()
+		err = sc.strm.close()
+		sc.srv.onClose(sc)
+	}
+	return err
+}
+
+func (sc *serverClient) watcher() {
+	sc.logger.Info("Starting watcher")
+	st := scsWatching
+	var sessId string
+	for st == scsWatching {
+		pt, sz, err := sc.strm.readHeader()
+		if err != nil {
+			sc.logger.Info("Could not read header (closed?), err=", err)
+			sc.Close()
+			return
+		}
+
+		if pt == ptMessage {
+			if len(sessId) == 0 {
+				sc.logger.Error("Read request received, but it is not authenticated, close the connection.")
+				sc.Close()
+				return
+			}
+
+			sc.lock.Lock()
+			if sc.state == scsWatching {
+				sc.state = scsReading
+				st = scsReading
+				sc.clntRead = sz
+			}
+			sc.lock.Unlock()
+
+			if st == scsReading {
+				err = sc.srv.scfg.ConnListener.OnRead(sc, sz)
+				if err != nil {
+					sc.logger.Warn("watcher(): listener rejected read, err=", err)
+					sc.Close()
+					return
+				}
+			}
+
+			sc.lock.Lock()
+			for sc.state == scsReading {
+				sc.cond.Wait()
+			}
+			st = sc.state
+			sc.lock.Unlock()
+		}
+
+		if pt == ptAuth {
+			ar, err := sc.strm.readAuthReq(sz)
+			if err != nil {
+				sc.logger.Warn("watcher(): could not read auth request, err=", err)
+				sc.Close()
+				return
+			}
+
+			sessId = sc.srv.authenticate(sc, &ar)
+
+			var resp AuthResp
+			resp.SessionId = strPtr(sessId)
+			resp.Terminal = len(sessId) == 0
+
+			err = sc.strm.writeAuthResp(&resp)
+			if err != nil {
+				sc.logger.Warn("watcher(): could not send auth response, err=", err)
+				sc.Close()
+				return
+			}
+
+			if len(sessId) == 0 {
+				sc.logger.Warn("watcher(): unauthenticated request ", &ar, ", will close it shortly.")
+				go func() {
+					select {
+					case <-sc.srv.ctx.Done():
+					case <-time.After(time.Second):
+					}
+					sc.Close()
+				}()
+				return
+			}
+		}
+	}
+	sc.logger.Info("watcher(): done. state=", st, ", but expecting scs_wathing(", scsWatching, ")")
+}
diff --git a/pkg/protocol/atmosphere/stream.go b/pkg/protocol/atmosphere/stream.go
new file mode 100644
index 0000000..419b548
--- /dev/null
+++ b/pkg/protocol/atmosphere/stream.go
@@ -0,0 +1,163 @@
+package atmosphere
+
+import (
+	"encoding/binary"
+	"encoding/json"
+	"io"
+
+	"github.com/jrivets/log4g"
+)
+
+type (
+	stream struct {
+		rbuf   []byte
+		rwc    io.ReadWriteCloser
+		logger log4g.Logger
+	}
+)
+
+func (s *stream) close() error {
+	return s.rwc.Close()
+}
+
+func (s *stream) readOrSkip(n int, buf []byte) error {
+	s.logger.Trace("readOrSkip(): n=", n, ", buf=", len(buf))
+	if n > len(buf) {
+		for n > 0 {
+			idx := len(s.rbuf)
+			if idx > n {
+				idx = n
+			}
+			rd, err := s.rwc.Read(s.rbuf[:idx])
+			if err != nil {
+				s.logger.Debug("readOrSkip(): err=", err)
+				return err
+			}
+			n -= rd
+		}
+		return nil
+	}
+	_, err := io.ReadFull(s.rwc, buf[:n])
+	return err
+}
+
+func (s *stream) authHandshake(ar *AuthReq) (AuthResp, error) {
+	err := s.writeAuthReq(ar)
+	if err != nil {
+		return AuthResp{}, err
+	}
+
+	return s.expectingAuthResp()
+}
+
+func (s *stream) writeAuthReq(ar *AuthReq) error {
+	buf, err := json.Marshal(ar)
+	if err != nil {
+		s.logger.Warn("writeAuthReq(): could not marshal ar=", ar, ", err=", err)
+		return err
+	}
+	s.logger.Debug("writeAuthReq(): wire buf=", string(buf))
+
+	return s.writeBuf(ptAuth, buf)
+}
+
+func (s *stream) writeAuthResp(ar *AuthResp) error {
+	buf, err := json.Marshal(ar)
+	if err != nil {
+		s.logger.Warn("writeAuthResp(): could not marshal ar=", ar, ", err=", err)
+		return err
+	}
+	s.logger.Debug("writeAuthResp(): wire buf=", string(buf))
+
+	return s.writeBuf(ptAuth, buf)
+}
+
+func (s *stream) readAuthReq(n int) (AuthReq, error) {
+	if len(s.rbuf) < n {
+		s.rbuf = make([]byte, n)
+	}
+
+	var req AuthReq
+	rb := s.rbuf[:n]
+	_, err := io.ReadFull(s.rwc, rb)
+	if err != nil {
+		return req, err
+	}
+
+	s.logger.Debug("readAuthReq(): wire buf=", string(rb))
+	err = json.Unmarshal(rb, &req)
+	return req, err
+}
+
+func (s *stream) expectingAuthResp() (AuthResp, error) {
+	tp, n, err := s.readHeader()
+	if err != nil {
+		return AuthResp{}, err
+	}
+	if tp != ptAuth {
+		return AuthResp{}, ErrStreamBroken
+	}
+
+	return s.readAuthResp(n)
+}
+
+func (s *stream) readAuthResp(n int) (AuthResp, error) {
+	if len(s.rbuf) < n {
+		s.rbuf = make([]byte, n)
+	}
+
+	var resp AuthResp
+	rb := s.rbuf[:n]
+	_, err := io.ReadFull(s.rwc, rb)
+	if err != nil {
+		return resp, err
+	}
+
+	s.logger.Debug("readAuthResp(): wire buf=", string(rb))
+	err = json.Unmarshal(rb, &resp)
+	return resp, err
+}
+
+func (s *stream) readHeader() (int, int, error) {
+	var buf [4]byte
+	bs := buf[:]
+	_, err := io.ReadFull(s.rwc, bs)
+	if err != nil {
+		return 0, 0, err
+	}
+	sz := int(binary.BigEndian.Uint32(bs))
+
+	bs = buf[:2]
+	_, err = io.ReadFull(s.rwc, bs)
+	if err != nil {
+		return 0, 0, err
+	}
+	typ := int(binary.BigEndian.Uint16(bs))
+
+	s.logger.Trace("readHeader(): sz=", sz, ", typ=", typ)
+
+	return typ, sz, nil
+}
+
+func (s *stream) writeBuf(pt int, datBuf []byte) error {
+	var buf [4]byte
+	bs := buf[:]
+	binary.BigEndian.PutUint32(bs, uint32(len(datBuf)))
+	_, err := s.rwc.Write(bs)
+	if err != nil {
+		return err
+	}
+
+	bs = buf[:2]
+	binary.BigEndian.PutUint16(bs, uint16(pt))
+	_, err = s.rwc.Write(bs)
+	if err != nil {
+		return err
+	}
+	s.logger.Trace("writeBuf(): sz=", len(datBuf), ", typ=", pt)
+
+	if len(datBuf) > 0 {
+		_, err = s.rwc.Write(datBuf)
+	}
+	return err
+}
diff --git a/pkg/protocol/atmosphere/test_certs/README.md b/pkg/protocol/atmosphere/test_certs/README.md
new file mode 100644
index 0000000..1d1d8bb
--- /dev/null
+++ b/pkg/protocol/atmosphere/test_certs/README.md
@@ -0,0 +1 @@
+The folder contains test certificates. server0.crt is signed up with SAN 127.0.0.1
\ No newline at end of file
diff --git a/pkg/protocol/atmosphere/test_certs/chain.pem b/pkg/protocol/atmosphere/test_certs/chain.pem
new file mode 100644
index 0000000..ad1dfc7
--- /dev/null
+++ b/pkg/protocol/atmosphere/test_certs/chain.pem
@@ -0,0 +1,46 @@
+-----BEGIN CERTIFICATE-----
+MIIDzzCCAregAwIBAgIBAjANBgkqhkiG9w0BAQUFADB0MRMwEQYKCZImiZPyLGQB
+GRYDb3JnMRYwFAYKCZImiZPyLGQBGRYGc2ltcGxlMRMwEQYDVQQKDApTaW1wbGUg
+SW5jMRcwFQYDVQQLDA5TaW1wbGUgUm9vdCBDQTEXMBUGA1UEAwwOU2ltcGxlIFJv
+b3QgQ0EwHhcNMTgwMjE0MjIxNTM1WhcNMjgwMjE0MjIxNTM1WjB6MRMwEQYKCZIm
+iZPyLGQBGRYDb3JnMRYwFAYKCZImiZPyLGQBGRYGc2ltcGxlMRMwEQYDVQQKDApT
+aW1wbGUgSW5jMRowGAYDVQQLDBFTaW1wbGUgU2lnbmluZyBDQTEaMBgGA1UEAwwR
+U2ltcGxlIFNpZ25pbmcgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB
+AQC5ZLEtWduqK8t5IUp4rT1t+5WCX0Zga5XPM8kSYJ95eekPhNf0hdFgZ5HorXTU
+4MMaN7yqbsIZcc4ACosDr9nK5DJadG6rX5oviyBOhWqEUwmjZWBHAGa/autAwFrB
+TZpULJsCmcl/DjDRkxl/X30yGI6fnDyMqux9Yfg+qu+uZsbLJ42blmqWc8ipU0YP
+A3ws8RP5XCFHzN7ULphNNuhQj0Rqu67jEDANAqQHkmhaYfzJKem0aT6U7cK0tkEu
+Zd3UWdLVAVjROvd8XDcBeN1UgaAP6DC7yz8CbW5skQuPJOepgTre0rg0Y9BIc+qZ
+RY3WMWhTjnF16lrLwxESUqWpAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNV
+HRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBSDHGpTC7R2FZ2ajXs5K3LNpMBp4zAf
+BgNVHSMEGDAWgBQSS4cFtLXIm46bt4ZNoEukDHUwjDANBgkqhkiG9w0BAQUFAAOC
+AQEAx7COJRQ9qM6bTYzsebB502Wy/UTEahZWVmn3ae1s350s1lWw5Xw5UCIkrh39
+RtDWml7qjQZPkbZoVeWD2e7egRgPqeV7JfKwT3GObgA0pZ/xsMyd8j/hWYw1OZvK
+9aWQW2hHzcpPMGIhbBa7bDTN29EAQZrLJ0poh5/ChdUlJOu9RFf8rVkY5KtokbsB
+KLrAghJ7xoeQyIROkpAtCdWPZdrk51nZt138ASodBLyqsRPHHRT3JVK8r71pUGuI
+/f38NdzIJ47fBEEoEECAwHHuSvjMgiDmmgwEKw9gF4iq/io1PJ4MLl/t5H3HzxvS
+PkNuc4aCcvkhWal0gWsn/bUjLg==
+-----END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIDxjCCAq6gAwIBAgIBATANBgkqhkiG9w0BAQUFADB0MRMwEQYKCZImiZPyLGQB
+GRYDb3JnMRYwFAYKCZImiZPyLGQBGRYGc2ltcGxlMRMwEQYDVQQKDApTaW1wbGUg
+SW5jMRcwFQYDVQQLDA5TaW1wbGUgUm9vdCBDQTEXMBUGA1UEAwwOU2ltcGxlIFJv
+b3QgQ0EwHhcNMTgwMjE0MjIwOTU3WhcNMjgwMjE0MjIwOTU3WjB0MRMwEQYKCZIm
+iZPyLGQBGRYDb3JnMRYwFAYKCZImiZPyLGQBGRYGc2ltcGxlMRMwEQYDVQQKDApT
+aW1wbGUgSW5jMRcwFQYDVQQLDA5TaW1wbGUgUm9vdCBDQTEXMBUGA1UEAwwOU2lt
+cGxlIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaYiM6
+w79Du3OkrxTb0e8DXS3Gv2hJHoWtnfLxNjOMyen0PqsPIc0mwwO3dvoUVIX9g0vx
+HV4zMuHTKZN1TU7hu1xc3JdNPjbWdHWwIa/kaDugCrSISXLHTl6FewfpaCqx4zFH
+uAQtX7K40tzVAWSlQX8xd95NqoIseXSHxtIeziB/hwrLOmz/gLLxKxFg4ZBFGyR4
+kUyidYXN25/B+eJpAoAYsxH1SQucwUn8dDatcy4aPwac13sS5o15ZWqCQTKAirb8
+LeJudrM2KhoHyHI8sXOG6DngEZVAjB2eimhOqEQraqnvMraeWef1Cz+TfQZAWA/w
+o3FK3Nc523Ikgfd5AgMBAAGjYzBhMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E
+BTADAQH/MB0GA1UdDgQWBBQSS4cFtLXIm46bt4ZNoEukDHUwjDAfBgNVHSMEGDAW
+gBQSS4cFtLXIm46bt4ZNoEukDHUwjDANBgkqhkiG9w0BAQUFAAOCAQEApmzMdCRp
+tri++8o3S+LjZzcudeU4JKK/oStjXdu4wHLSqTRpsXVPFh1Zfgt/tYcfQaqyMYZa
+ER3wobZ1+G7mql3+u5/bTeiJSZ7CSifvl4YHjZkrrPyF1zE+6u9SjpJXCN2yu/Lx
+HBAT6E6OPixVCiWlYRFo9scQSWO+/OvsR11tINvfJs1vrTB0K93UZjHA9d23brxO
+9r+/yqPmKddJbPLTucj8iDWesH7Ye6NCPv6S5W+3CAnlRUg6tTZrUyCi//pto4W7
+LuwQxWmPv7m22agaeWJqb/301IUmeGNJtwYMEmKeQwWVbcWVxvGXuR3lYpECXGS0
+bYowfs3sU/pR/g==
+-----END CERTIFICATE-----
diff --git a/pkg/protocol/atmosphere/test_certs/client.crt b/pkg/protocol/atmosphere/test_certs/client.crt
new file mode 100644
index 0000000..9b6a519
--- /dev/null
+++ b/pkg/protocol/atmosphere/test_certs/client.crt
@@ -0,0 +1,87 @@
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 2 (0x2)
+    Signature Algorithm: sha1WithRSAEncryption
+        Issuer: DC=org, DC=simple, O=Simple Inc, OU=Simple Signing CA, CN=Simple Signing CA
+        Validity
+            Not Before: Feb 14 23:21:41 2018 GMT
+            Not After : Feb 14 23:21:41 2020 GMT
+        Subject: DC=simple, DC=simple, O=Simple Inc, OU=Simple Inc, CN=www.simple.com
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                Public-Key: (2048 bit)
+                Modulus:
+                    00:c2:fb:44:08:6b:25:0b:84:97:d4:c5:90:06:89:
+                    3f:d5:e3:03:7c:0c:4e:1d:a1:3c:f2:d8:57:28:7a:
+                    48:72:be:6b:0c:6a:08:91:ec:9f:18:3d:77:03:c0:
+                    9d:71:57:54:55:bc:8a:68:ca:25:89:dc:d3:7f:e1:
+                    f6:b2:9d:e0:ba:29:d3:bb:83:d3:ca:0f:9f:65:d3:
+                    11:39:e3:a3:c4:e6:0d:26:58:43:47:65:02:d3:a2:
+                    78:1d:82:2c:60:dd:80:60:ba:fa:30:5a:7d:a2:73:
+                    20:d1:d0:1e:53:15:9b:c8:c4:a5:fb:8f:84:6c:cc:
+                    b2:fe:d6:d0:af:22:a6:50:97:77:48:f5:ab:c9:9e:
+                    cc:15:8b:5f:04:b2:36:46:53:dc:37:45:08:43:8f:
+                    8e:6b:ab:93:c0:34:c7:e9:50:be:37:8f:91:5b:d9:
+                    85:13:d2:69:d2:41:30:ca:53:8e:72:9a:38:3f:c0:
+                    92:2a:9c:ad:50:8f:3a:7b:22:b9:ea:6d:5b:eb:a5:
+                    9c:05:4b:47:ee:2d:79:3f:d5:14:4b:57:8e:97:13:
+                    59:da:ed:f6:a0:ec:de:6c:ec:da:8a:2b:b7:ad:11:
+                    91:20:a5:6e:7e:45:0b:0b:59:d9:cb:48:8f:2f:1f:
+                    f7:f5:ef:0d:e8:72:07:4d:09:a8:86:b0:5e:ed:5e:
+                    d6:e9
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Key Usage: critical
+                Digital Signature, Key Encipherment
+            X509v3 Basic Constraints: 
+                CA:FALSE
+            X509v3 Extended Key Usage: 
+                E-mail Protection, TLS Web Client Authentication
+            X509v3 Subject Key Identifier: 
+                C0:85:96:34:CC:9A:95:2A:B6:98:50:AF:69:44:FB:71:76:C9:60:BE
+            X509v3 Authority Key Identifier: 
+                keyid:83:1C:6A:53:0B:B4:76:15:9D:9A:8D:7B:39:2B:72:CD:A4:C0:69:E3
+
+            X509v3 Subject Alternative Name: 
+                DNS:www.simple.org
+    Signature Algorithm: sha1WithRSAEncryption
+         96:42:d1:a3:6a:9f:ef:bd:62:7d:95:6f:d5:63:45:7c:f7:72:
+         07:7f:23:f1:2f:5b:f3:03:78:c0:d2:a4:a5:14:aa:84:cd:85:
+         8b:39:f8:4f:fc:8c:f1:26:d4:1f:52:d0:ff:81:c8:13:72:83:
+         45:f7:ee:fb:21:df:b7:65:54:b2:ee:af:26:e5:fc:7f:94:ea:
+         29:12:46:61:46:e6:c8:dd:c2:0f:ab:24:0f:77:83:2d:f2:c6:
+         e7:68:ed:de:4f:62:ee:57:4a:d1:5e:d7:dc:f5:f6:03:31:4d:
+         92:32:90:70:d8:fa:2e:8d:51:d1:90:6c:f2:77:6c:82:f6:4a:
+         72:68:0d:3e:c3:78:a3:a0:0b:3f:c7:0b:54:c1:d5:ca:7e:f4:
+         9b:d7:72:ef:f0:5a:31:38:ec:08:8b:ea:40:42:42:14:91:61:
+         2a:e3:03:2c:ae:c3:2c:4d:de:43:4e:a7:d5:ca:a9:17:6b:e0:
+         46:8e:d2:d9:6c:9a:65:e2:7f:24:58:9a:2b:ff:82:81:51:09:
+         21:48:73:ea:0c:91:95:c2:e6:41:5b:dd:ab:87:84:8f:4f:e2:
+         b0:65:ee:f7:f9:5b:69:3b:19:8e:b0:26:2c:97:49:ce:04:80:
+         e4:bd:c8:cf:06:be:97:b7:3b:dc:7d:c8:d5:d2:22:f4:fc:65:
+         6a:7e:7f:4d
+-----BEGIN CERTIFICATE-----
+MIIEATCCAumgAwIBAgIBAjANBgkqhkiG9w0BAQUFADB6MRMwEQYKCZImiZPyLGQB
+GRYDb3JnMRYwFAYKCZImiZPyLGQBGRYGc2ltcGxlMRMwEQYDVQQKDApTaW1wbGUg
+SW5jMRowGAYDVQQLDBFTaW1wbGUgU2lnbmluZyBDQTEaMBgGA1UEAwwRU2ltcGxl
+IFNpZ25pbmcgQ0EwHhcNMTgwMjE0MjMyMTQxWhcNMjAwMjE0MjMyMTQxWjBzMRYw
+FAYKCZImiZPyLGQBGRYGc2ltcGxlMRYwFAYKCZImiZPyLGQBGRYGc2ltcGxlMRMw
+EQYDVQQKDApTaW1wbGUgSW5jMRMwEQYDVQQLDApTaW1wbGUgSW5jMRcwFQYDVQQD
+DA53d3cuc2ltcGxlLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
+AML7RAhrJQuEl9TFkAaJP9XjA3wMTh2hPPLYVyh6SHK+awxqCJHsnxg9dwPAnXFX
+VFW8imjKJYnc03/h9rKd4Lop07uD08oPn2XTETnjo8TmDSZYQ0dlAtOieB2CLGDd
+gGC6+jBafaJzINHQHlMVm8jEpfuPhGzMsv7W0K8iplCXd0j1q8mezBWLXwSyNkZT
+3DdFCEOPjmurk8A0x+lQvjePkVvZhRPSadJBMMpTjnKaOD/AkiqcrVCPOnsiuept
+W+ulnAVLR+4teT/VFEtXjpcTWdrt9qDs3mzs2oort60RkSClbn5FCwtZ2ctIjy8f
+9/XvDehyB00JqIawXu1e1ukCAwEAAaOBmDCBlTAOBgNVHQ8BAf8EBAMCBaAwCQYD
+VR0TBAIwADAdBgNVHSUEFjAUBggrBgEFBQcDBAYIKwYBBQUHAwIwHQYDVR0OBBYE
+FMCFljTMmpUqtphQr2lE+3F2yWC+MB8GA1UdIwQYMBaAFIMcalMLtHYVnZqNezkr
+cs2kwGnjMBkGA1UdEQQSMBCCDnd3dy5zaW1wbGUub3JnMA0GCSqGSIb3DQEBBQUA
+A4IBAQCWQtGjap/vvWJ9lW/VY0V893IHfyPxL1vzA3jA0qSlFKqEzYWLOfhP/Izx
+JtQfUtD/gcgTcoNF9+77Id+3ZVSy7q8m5fx/lOopEkZhRubI3cIPqyQPd4Mt8sbn
+aO3eT2LuV0rRXtfc9fYDMU2SMpBw2PoujVHRkGzyd2yC9kpyaA0+w3ijoAs/xwtU
+wdXKfvSb13Lv8FoxOOwIi+pAQkIUkWEq4wMsrsMsTd5DTqfVyqkXa+BGjtLZbJpl
+4n8kWJor/4KBUQkhSHPqDJGVwuZBW92rh4SPT+KwZe73+VtpOxmOsCYsl0nOBIDk
+vcjPBr6XtzvcfcjV0iL0/GVqfn9N
+-----END CERTIFICATE-----
diff --git a/pkg/protocol/atmosphere/test_certs/client.key b/pkg/protocol/atmosphere/test_certs/client.key
new file mode 100644
index 0000000..c93f04d
--- /dev/null
+++ b/pkg/protocol/atmosphere/test_certs/client.key
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDC+0QIayULhJfU
+xZAGiT/V4wN8DE4doTzy2FcoekhyvmsMagiR7J8YPXcDwJ1xV1RVvIpoyiWJ3NN/
+4fayneC6KdO7g9PKD59l0xE546PE5g0mWENHZQLTongdgixg3YBguvowWn2icyDR
+0B5TFZvIxKX7j4RszLL+1tCvIqZQl3dI9avJnswVi18EsjZGU9w3RQhDj45rq5PA
+NMfpUL43j5Fb2YUT0mnSQTDKU45ymjg/wJIqnK1Qjzp7IrnqbVvrpZwFS0fuLXk/
+1RRLV46XE1na7fag7N5s7NqKK7etEZEgpW5+RQsLWdnLSI8vH/f17w3ocgdNCaiG
+sF7tXtbpAgMBAAECggEAA5N8MfNVIJrz9fERrS0DQLcDL1lCbYSxi3qwTou/nGsl
+p3qiYZrHaDhoYGc9/AAwCcqFd1qNybOFJYlNbwU6Q+/UdFH8pm4W7FUssbUdIdVe
+VF+2DC8sGBmYvmHO0o/9dMi5If3m4/3ckjyQ8dEppEsHCFAfi6dNeSMTfMLT7hJw
+6ZxHo50m+pXLsGY+AyB8hwA3ahjfGSPuLuZa3PnMZvts6nL65vBbzfUzByQyI92a
+DGCENB2xyN4kCXTHbpWRXAPhdZ5vjq6EshnqqbJsSPR8mMFN+BN7gU+G1DDBbmU2
+Iln34loTkZ34/reINzoWgFRauax9YKzzcBHHlOOjSQKBgQDfqPr6w6WZxUY1EL8O
+2GSdULejsKn0Q+4jgS3edS5z108dddcr4XAn+Vsnm6tfkXbyd3qxytAF8pvoqqic
+JHpohB1XMJ7wgISMJ9HaZ5VyluwZKmwL7DfARHxSIEWN1sRi+vWZ/Fyw2OAfYpAY
+yjs0LnCfjizuFnhYpafPdK1tUwKBgQDfLLeM1vMbXilrFTBndRHSZA0XaKqQyBtL
+Ato8qGK+EemUTELOWie+KMO/2Fpi1UQW7n0gjxoy9ghsvEiEI3JS6FVEFd3tjZcr
+JsppQM++bC6W5OvTaQEG/MWxyq4EiKP2cKImORPRGrg2pD4Dpm0g+ZMUCzWKRPrs
+1vom+DhnUwKBgBM5UgE1yckSxLsQ6msbPGKtKmueZq1BHXndw5SIW+rHCdzNYSY7
+ZUl6TFR2M9+uABxNGrWnagPo22+/I2jwVbkgCemRm0eutDXbwlTUbGsB/98V312S
++yPCfzEL5w6O9ChRy8RlhY4JxhHMhfgrgbU1fKaqMMByG/v6mRbiv3lTAoGAcckU
+1IQLcxqxN12YTkdMDN7iJdtBi4vbDoWny2F25r2vP+MZ9KfWt4eFNl0SyG0/yAlU
+VrNfgjga14Wv219PPKIkRxB3FFUqi9+9N6jJwqbZoimZazKQSYW7LgjObJVWM6H9
+qktTpTtgTMu0qpvB7BwTNxb390VwQizhYdkQuO0CgYEAttDuM9yGvxu5lD8od5J8
+vYQHjxTjTd66ngIr354bcZmIntOkvSvDXTurakzTF5x0K84JU1Ap5orolJAtxIcj
+kjWD8g+IWqygogRvz28KyBO3EADghEMHTZ/w0CrkEYMdj2OMIPwEavB3hTDZpjzD
+bMmrHUDLfMWk97iEGZGwPy4=
+-----END PRIVATE KEY-----
diff --git a/pkg/protocol/atmosphere/test_certs/client0.crt b/pkg/protocol/atmosphere/test_certs/client0.crt
new file mode 100644
index 0000000..e44c124
--- /dev/null
+++ b/pkg/protocol/atmosphere/test_certs/client0.crt
@@ -0,0 +1,87 @@
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 4 (0x4)
+    Signature Algorithm: sha1WithRSAEncryption
+        Issuer: DC=org, DC=simple, O=Simple Inc, OU=Simple Signing CA, CN=Simple Signing CA
+        Validity
+            Not Before: Feb 15 06:51:38 2018 GMT
+            Not After : Feb 15 06:51:38 2020 GMT
+        Subject: DC=org, DC=simple, O=Simple Inc, OU=Simple Inc, CN=IP:127.0.0.1
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                Public-Key: (2048 bit)
+                Modulus:
+                    00:be:17:27:69:39:d1:f4:8e:ab:9e:18:e1:b3:6a:
+                    81:8e:f5:d1:64:91:0a:35:cd:81:27:a9:97:ea:5d:
+                    f8:a7:67:f6:b0:b8:fe:62:76:f8:78:29:27:a6:1d:
+                    cc:3c:2d:be:33:f8:9c:5d:47:f1:c8:db:28:f9:87:
+                    43:28:0e:d9:1a:4f:ae:11:e0:93:7d:e4:a1:19:01:
+                    04:03:ff:28:27:9c:0c:f6:02:14:fd:34:cb:12:f7:
+                    06:f2:61:a6:19:1e:af:c0:8a:a3:83:84:b5:d2:bc:
+                    78:f5:5f:61:3c:ac:40:eb:c3:0f:bc:f1:f0:e4:ec:
+                    6a:ab:3b:4a:f0:49:3d:91:08:f2:50:81:00:0e:75:
+                    63:ed:62:cb:6a:12:95:b1:b0:6b:a0:4b:3e:44:55:
+                    bd:92:30:a1:74:e9:8a:fc:ed:98:2e:6f:19:b8:a6:
+                    00:8d:d8:95:6a:02:15:fe:3f:a0:28:1a:d4:ab:c6:
+                    65:3b:7b:9c:a4:d9:c3:59:e4:79:8f:ad:c5:4b:be:
+                    2a:ef:f5:27:01:8c:f4:15:ed:a6:db:6d:9e:aa:b1:
+                    56:f1:98:a7:bc:b5:07:c6:10:2e:50:79:8d:cf:58:
+                    d5:4d:c5:14:fc:15:6d:e7:cd:51:3b:73:65:06:e0:
+                    da:09:83:6d:ae:74:7d:d1:45:96:21:a1:4d:eb:98:
+                    9a:99
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Key Usage: critical
+                Digital Signature, Key Encipherment
+            X509v3 Basic Constraints: 
+                CA:FALSE
+            X509v3 Extended Key Usage: 
+                E-mail Protection, TLS Web Client Authentication
+            X509v3 Subject Key Identifier: 
+                37:00:7D:B8:9E:DD:07:F3:A7:51:0F:59:D5:13:DD:B1:C4:ED:CB:A0
+            X509v3 Authority Key Identifier: 
+                keyid:83:1C:6A:53:0B:B4:76:15:9D:9A:8D:7B:39:2B:72:CD:A4:C0:69:E3
+
+            X509v3 Subject Alternative Name: 
+                DNS:yourdomain.tld
+    Signature Algorithm: sha1WithRSAEncryption
+         4c:30:08:35:f3:dc:b9:27:e9:6f:59:49:2d:40:6a:88:bb:6c:
+         28:8f:db:66:30:92:61:49:fa:d5:c3:23:7d:de:e6:3c:16:0b:
+         eb:f9:2e:49:bb:d8:cd:c3:be:1a:a8:77:0f:84:b5:5e:f2:a7:
+         c0:7a:26:ec:64:61:7c:ce:68:d3:ae:3d:27:e9:42:d5:1b:a7:
+         25:a9:1d:b3:09:1c:ef:ce:57:9e:c4:2a:86:f5:25:54:b4:6d:
+         1d:60:6c:79:35:95:12:e9:b3:ff:0f:0c:60:71:97:bd:14:8c:
+         fa:0c:34:5e:d6:49:25:66:11:3d:a5:a8:3d:f1:08:13:57:16:
+         69:c2:59:8f:26:48:b2:10:b3:4e:b4:0f:a0:c5:6f:d9:41:a9:
+         93:76:ff:7b:b7:89:a8:4d:04:16:a4:53:93:0f:e1:53:13:0c:
+         9d:1b:72:f5:54:d4:ed:1d:5d:ce:17:50:44:33:e6:d5:38:09:
+         88:48:22:55:72:ee:91:1a:6e:58:f4:df:cd:d4:55:d4:69:8b:
+         b1:e8:ad:f9:65:90:d4:2d:cf:d4:fe:db:ac:da:ac:19:b3:e0:
+         a4:ad:d5:82:38:44:ab:71:34:2d:e5:a5:be:ca:b4:7d:45:54:
+         a1:9c:00:a5:37:1c:55:f0:69:44:b1:9f:11:91:bc:19:b0:bd:
+         3c:e9:27:d9
+-----BEGIN CERTIFICATE-----
+MIID/DCCAuSgAwIBAgIBBDANBgkqhkiG9w0BAQUFADB6MRMwEQYKCZImiZPyLGQB
+GRYDb3JnMRYwFAYKCZImiZPyLGQBGRYGc2ltcGxlMRMwEQYDVQQKDApTaW1wbGUg
+SW5jMRowGAYDVQQLDBFTaW1wbGUgU2lnbmluZyBDQTEaMBgGA1UEAwwRU2ltcGxl
+IFNpZ25pbmcgQ0EwHhcNMTgwMjE1MDY1MTM4WhcNMjAwMjE1MDY1MTM4WjBuMRMw
+EQYKCZImiZPyLGQBGRYDb3JnMRYwFAYKCZImiZPyLGQBGRYGc2ltcGxlMRMwEQYD
+VQQKDApTaW1wbGUgSW5jMRMwEQYDVQQLDApTaW1wbGUgSW5jMRUwEwYDVQQDDAxJ
+UDoxMjcuMC4wLjEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC+Fydp
+OdH0jqueGOGzaoGO9dFkkQo1zYEnqZfqXfinZ/awuP5idvh4KSemHcw8Lb4z+Jxd
+R/HI2yj5h0MoDtkaT64R4JN95KEZAQQD/ygnnAz2AhT9NMsS9wbyYaYZHq/AiqOD
+hLXSvHj1X2E8rEDrww+88fDk7GqrO0rwST2RCPJQgQAOdWPtYstqEpWxsGugSz5E
+Vb2SMKF06Yr87Zgubxm4pgCN2JVqAhX+P6AoGtSrxmU7e5yk2cNZ5HmPrcVLvirv
+9ScBjPQV7abbbZ6qsVbxmKe8tQfGEC5QeY3PWNVNxRT8FW3nzVE7c2UG4NoJg22u
+dH3RRZYhoU3rmJqZAgMBAAGjgZgwgZUwDgYDVR0PAQH/BAQDAgWgMAkGA1UdEwQC
+MAAwHQYDVR0lBBYwFAYIKwYBBQUHAwQGCCsGAQUFBwMCMB0GA1UdDgQWBBQ3AH24
+nt0H86dRD1nVE92xxO3LoDAfBgNVHSMEGDAWgBSDHGpTC7R2FZ2ajXs5K3LNpMBp
+4zAZBgNVHREEEjAQgg55b3VyZG9tYWluLnRsZDANBgkqhkiG9w0BAQUFAAOCAQEA
+TDAINfPcuSfpb1lJLUBqiLtsKI/bZjCSYUn61cMjfd7mPBYL6/kuSbvYzcO+Gqh3
+D4S1XvKnwHom7GRhfM5o0649J+lC1RunJakdswkc785XnsQqhvUlVLRtHWBseTWV
+Eumz/w8MYHGXvRSM+gw0XtZJJWYRPaWoPfEIE1cWacJZjyZIshCzTrQPoMVv2UGp
+k3b/e7eJqE0EFqRTkw/hUxMMnRty9VTU7R1dzhdQRDPm1TgJiEgiVXLukRpuWPTf
+zdRV1GmLseit+WWQ1C3P1P7brNqsGbPgpK3VgjhEq3E0LeWlvsq0fUVUoZwApTcc
+VfBpRLGfEZG8GbC9POkn2Q==
+-----END CERTIFICATE-----
diff --git a/pkg/protocol/atmosphere/test_certs/client0.key b/pkg/protocol/atmosphere/test_certs/client0.key
new file mode 100644
index 0000000..3e64d3b
--- /dev/null
+++ b/pkg/protocol/atmosphere/test_certs/client0.key
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC+FydpOdH0jque
+GOGzaoGO9dFkkQo1zYEnqZfqXfinZ/awuP5idvh4KSemHcw8Lb4z+JxdR/HI2yj5
+h0MoDtkaT64R4JN95KEZAQQD/ygnnAz2AhT9NMsS9wbyYaYZHq/AiqODhLXSvHj1
+X2E8rEDrww+88fDk7GqrO0rwST2RCPJQgQAOdWPtYstqEpWxsGugSz5EVb2SMKF0
+6Yr87Zgubxm4pgCN2JVqAhX+P6AoGtSrxmU7e5yk2cNZ5HmPrcVLvirv9ScBjPQV
+7abbbZ6qsVbxmKe8tQfGEC5QeY3PWNVNxRT8FW3nzVE7c2UG4NoJg22udH3RRZYh
+oU3rmJqZAgMBAAECggEAaMieovSKdcLHe2i/0YTeUg3TFRqWhD35+gEUis6uKKm4
+ZIY1Q9XM9X/KKVm3oVydwkxC9XCZKV0V4ybasBQvPL+7doNTCkyjOQNEUWevnNX6
+lwlixIj7gELHg4isZKBzxTEnHXJkP/xAuRGQqj9RsiReYosDfU2NJ0KR9o6I748J
+Ir5maXdBem1V6xxItQIu0zvs0J64PIFVzaAsj0OFZ72PQd+V5n9NOXtD5IRB2iiq
+2OIXlotyg7qtl/JCY4MYukS7VCt6/qiiWqg2oAiVwmzCc0goZy9hWEWF7MriXceE
+KBWLk5cyE/hvbW8Bk3HRJDFdjKE6KqhGKtmrzmbLGQKBgQDs0fOANJ5YVho6mTRR
+JvJF1/ppBly2smQqdr4LWJA4nGWHxQ7rmQAG12w/uFUZ5H/Cijh4p61zccSslmFm
+IKHvBflpldz9iaqlNseZJvINjAW1T/ppT59/qHXcdlCvVCwumFlw+kx/E4ltsgES
+ZnyiCUIxhoz9y8Q0FK370wfsDwKBgQDNfFhYCn85nJepHme6sJ6vgH9upIPT0NXf
+jTbdHUyS85EGYjOT1+H70uIML/KOx2SrT9mEfTiTW7iTKqIODL+kr+H/CfiI3Prc
+sBsPiBJAaexhPqy+ouKI7QqQwx+XiuDmJezBb3m5eaRPNQup0DM0p/vyZs+gtFJP
+VbMdNAcG1wKBgDN3sYbkaKFkHREtKJyWbULWnHpkwpOGE5TS95x5o+ZZvwsRvZtg
+Rgw2lzUF96DH8ygxZ/J45o5XZFnp2MMcRnUvBDR5OGz1lVuQmzJir2pYSwlLl215
+u30//FVsdT6VeYCq5Y1TKHrZoR1w+SCpm16Pyo3+4vdpaHu1HtbC107rAoGBAMIY
+QhpnT+VLVLYaUkC1tC5yYexQ2XSqPlr7OGeD1WC5ULOG7tEnif4kJAD/CU50aVKo
+Cf5riZUnfiEElC5RPHSC7iXJdUlR8mOitOzmytatNupkGSe5E+HihahXpu+t7uF1
+0Tyl34SiseFfabTtRHDoe8Nr+ZMCwPzPJnDfRAPhAoGBALFp8U6jBJ8Mqe2wcT4m
+473sGzbmvw8tzm4LEYUikWDJfdHxnUdcYNLxbNblR70K2bBx8o8fG5qlxXNaz5lA
+VeqnsBzO7ju6AlO7HPnvi4GXlmU+kply/5tUrofjmkTXP1VH3W38FTpxqx8p7jsa
+/4dZ/GyRtZnsB8d+SFrcSbXQ
+-----END PRIVATE KEY-----
diff --git a/pkg/protocol/atmosphere/test_certs/server.crt b/pkg/protocol/atmosphere/test_certs/server.crt
new file mode 100644
index 0000000..520f575
--- /dev/null
+++ b/pkg/protocol/atmosphere/test_certs/server.crt
@@ -0,0 +1,87 @@
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 1 (0x1)
+    Signature Algorithm: sha1WithRSAEncryption
+        Issuer: DC=org, DC=simple, O=Simple Inc, OU=Simple Signing CA, CN=Simple Signing CA
+        Validity
+            Not Before: Feb 14 23:20:39 2018 GMT
+            Not After : Feb 14 23:20:39 2020 GMT
+        Subject: DC=simple, DC=simple, O=Simple Inc, OU=Simple Inc, CN=www.simple.com
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                Public-Key: (2048 bit)
+                Modulus:
+                    00:c9:05:63:d9:eb:3f:44:9c:1a:8f:c5:4e:15:24:
+                    4b:72:df:bc:c4:40:74:02:32:ea:64:58:07:1e:22:
+                    c5:1a:6d:e5:57:9b:6d:77:8a:3d:58:5c:06:7d:ba:
+                    d9:c0:fd:12:8a:34:16:bc:37:11:9c:36:53:1a:9a:
+                    97:0f:85:82:8e:1e:d0:a0:76:c1:82:cf:16:2e:c9:
+                    e5:d0:ce:70:93:73:d2:dc:64:bf:79:a0:5f:6a:57:
+                    52:c0:74:cc:ce:69:45:29:d7:8d:43:9c:a1:99:0b:
+                    42:26:a9:8b:77:0e:66:71:60:a2:01:b3:f0:2e:94:
+                    9b:ca:c7:3c:7b:80:d6:af:05:2f:31:5a:22:9e:8d:
+                    d6:ee:f4:00:1d:13:fb:1c:27:87:35:39:37:2d:28:
+                    da:35:fc:a6:75:21:27:ec:4a:0a:34:a5:8e:62:95:
+                    11:95:d4:37:a3:d3:59:df:59:fd:19:00:37:38:ed:
+                    8d:24:63:8b:31:83:9a:86:42:25:15:27:40:5d:1c:
+                    3e:82:3c:b6:d9:05:15:9f:7e:f5:09:8d:15:8f:d6:
+                    38:c3:96:d8:ac:bf:cc:dd:82:3f:a7:d7:7a:79:e1:
+                    a0:b0:27:41:0a:06:d0:93:be:70:8d:22:f8:95:29:
+                    d0:54:85:2c:ad:1b:81:50:a2:cd:0d:9c:e8:15:6a:
+                    e3:89
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Key Usage: critical
+                Digital Signature, Key Encipherment
+            X509v3 Basic Constraints: 
+                CA:FALSE
+            X509v3 Extended Key Usage: 
+                TLS Web Server Authentication, TLS Web Client Authentication
+            X509v3 Subject Key Identifier: 
+                D1:25:73:B9:4B:D6:B1:24:41:60:75:0A:16:A3:4E:EA:DB:CA:98:F3
+            X509v3 Authority Key Identifier: 
+                keyid:83:1C:6A:53:0B:B4:76:15:9D:9A:8D:7B:39:2B:72:CD:A4:C0:69:E3
+
+            X509v3 Subject Alternative Name: 
+                DNS:www.simple.org
+    Signature Algorithm: sha1WithRSAEncryption
+         92:d0:dd:ad:07:72:10:9c:cf:92:2b:1b:6c:4f:e2:8b:94:b3:
+         bb:26:1b:e3:10:49:f0:28:3f:73:bf:ad:56:ed:16:c3:57:c9:
+         48:4d:2b:64:35:39:55:c6:b5:cc:a7:f9:ef:3c:49:8d:06:39:
+         1a:8c:07:ea:17:58:b4:5b:51:1f:b2:08:40:45:c3:0e:c9:82:
+         a5:eb:56:71:98:07:89:3a:b0:8b:1b:ea:d0:91:d8:f7:63:61:
+         da:e7:2a:5d:00:c2:ff:53:71:f6:34:db:3a:df:73:95:d5:aa:
+         4f:eb:ce:ef:27:06:64:7e:31:3e:11:df:36:c0:e2:4e:69:8d:
+         cf:fb:1e:a3:0c:81:2d:1d:af:9f:ce:02:c6:61:51:79:a0:ea:
+         61:7a:b7:18:79:fc:a3:3b:64:96:e1:72:a7:ad:9c:7c:42:db:
+         8f:6f:79:2b:cf:72:a2:1b:d2:ef:5a:3d:cd:94:94:d2:aa:41:
+         fd:e4:8d:cd:14:4a:7f:c8:c4:eb:62:7f:e1:c5:6b:a2:8b:7f:
+         e9:ba:f9:51:09:de:25:5a:22:84:7f:55:56:42:30:be:04:a4:
+         38:1b:43:7e:5f:da:12:4d:1f:53:c3:cc:52:fb:72:7b:66:52:
+         f5:0b:cf:f2:2a:14:e9:8e:30:1a:97:8b:10:fa:39:60:a8:f6:
+         dd:01:58:ab
+-----BEGIN CERTIFICATE-----
+MIIEATCCAumgAwIBAgIBATANBgkqhkiG9w0BAQUFADB6MRMwEQYKCZImiZPyLGQB
+GRYDb3JnMRYwFAYKCZImiZPyLGQBGRYGc2ltcGxlMRMwEQYDVQQKDApTaW1wbGUg
+SW5jMRowGAYDVQQLDBFTaW1wbGUgU2lnbmluZyBDQTEaMBgGA1UEAwwRU2ltcGxl
+IFNpZ25pbmcgQ0EwHhcNMTgwMjE0MjMyMDM5WhcNMjAwMjE0MjMyMDM5WjBzMRYw
+FAYKCZImiZPyLGQBGRYGc2ltcGxlMRYwFAYKCZImiZPyLGQBGRYGc2ltcGxlMRMw
+EQYDVQQKDApTaW1wbGUgSW5jMRMwEQYDVQQLDApTaW1wbGUgSW5jMRcwFQYDVQQD
+DA53d3cuc2ltcGxlLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
+AMkFY9nrP0ScGo/FThUkS3LfvMRAdAIy6mRYBx4ixRpt5VebbXeKPVhcBn262cD9
+Eoo0Frw3EZw2Uxqalw+Fgo4e0KB2wYLPFi7J5dDOcJNz0txkv3mgX2pXUsB0zM5p
+RSnXjUOcoZkLQiapi3cOZnFgogGz8C6Um8rHPHuA1q8FLzFaIp6N1u70AB0T+xwn
+hzU5Ny0o2jX8pnUhJ+xKCjSljmKVEZXUN6PTWd9Z/RkANzjtjSRjizGDmoZCJRUn
+QF0cPoI8ttkFFZ9+9QmNFY/WOMOW2Ky/zN2CP6fXennhoLAnQQoG0JO+cI0i+JUp
+0FSFLK0bgVCizQ2c6BVq44kCAwEAAaOBmDCBlTAOBgNVHQ8BAf8EBAMCBaAwCQYD
+VR0TBAIwADAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwHQYDVR0OBBYE
+FNElc7lL1rEkQWB1ChajTurbypjzMB8GA1UdIwQYMBaAFIMcalMLtHYVnZqNezkr
+cs2kwGnjMBkGA1UdEQQSMBCCDnd3dy5zaW1wbGUub3JnMA0GCSqGSIb3DQEBBQUA
+A4IBAQCS0N2tB3IQnM+SKxtsT+KLlLO7JhvjEEnwKD9zv61W7RbDV8lITStkNTlV
+xrXMp/nvPEmNBjkajAfqF1i0W1EfsghARcMOyYKl61ZxmAeJOrCLG+rQkdj3Y2Ha
+5ypdAML/U3H2NNs633OV1apP687vJwZkfjE+Ed82wOJOaY3P+x6jDIEtHa+fzgLG
+YVF5oOphercYefyjO2SW4XKnrZx8QtuPb3krz3KiG9LvWj3NlJTSqkH95I3NFEp/
+yMTrYn/hxWuii3/puvlRCd4lWiKEf1VWQjC+BKQ4G0N+X9oSTR9Tw8xS+3J7ZlL1
+C8/yKhTpjjAal4sQ+jlgqPbdAVir
+-----END CERTIFICATE-----
diff --git a/pkg/protocol/atmosphere/test_certs/server.key b/pkg/protocol/atmosphere/test_certs/server.key
new file mode 100644
index 0000000..27739f2
--- /dev/null
+++ b/pkg/protocol/atmosphere/test_certs/server.key
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDJBWPZ6z9EnBqP
+xU4VJEty37zEQHQCMupkWAceIsUabeVXm213ij1YXAZ9utnA/RKKNBa8NxGcNlMa
+mpcPhYKOHtCgdsGCzxYuyeXQznCTc9LcZL95oF9qV1LAdMzOaUUp141DnKGZC0Im
+qYt3DmZxYKIBs/AulJvKxzx7gNavBS8xWiKejdbu9AAdE/scJ4c1OTctKNo1/KZ1
+ISfsSgo0pY5ilRGV1Dej01nfWf0ZADc47Y0kY4sxg5qGQiUVJ0BdHD6CPLbZBRWf
+fvUJjRWP1jjDltisv8zdgj+n13p54aCwJ0EKBtCTvnCNIviVKdBUhSytG4FQos0N
+nOgVauOJAgMBAAECggEAYSZ6uGHKBOWQrLUFZJBS6mSY/RvNNRbYUsB8SCMzsO81
+rJ5QTDqCJUbsWC1KecuU/zfnWPUgTKewiCX4Jac3jmn0F+js4sQki15F9CEhJRIP
+8TW7mBNaqbEkLCEGricQJwWmnut+6dEYGklMPrC178ts4HfO9yQZGuopH+MHXjO+
+gbPfjC1z+y4LMxGTe1qF/2fmmvhK9ISSbFnX+h50B/hLvHRnnnQYwBnsxxw70TgQ
+m95Z8aWuT2Qp+I74cE6kGmYxWYGVZlnxAEHDOyGD9FTlHW3ht6NyReq59Ib5E8s1
+BjQcsRZeo1cqkLChtiARUtCXbHNvUxOqXNkiV/WokQKBgQDxuAqXEjz1qxBRd/No
+UeX84P9ro4+Dvp24TdkjX0sMg+EQKvR+ElECqKwfS2hMCVwYQAban8Q9yfuEQpWm
+Jk5trZ+503DSeaPg42NKFwbXjbNQeNTOGWaS5e5k7S/YHvhRth0w6c73xSt4lNug
+uLtAa39HYb2plwXzLGodQO5bLQKBgQDU5czhP1hrcrxjwDSrnL4t327flVgDzI6e
+OazWYA2o4F0BgUAeMi3/pHZC6zpa0O/x+AtzTdl9QsjG8asU1q/8hUr5WXHecMM6
+lcIRedZOxduK5SChdx9vxR4wZPzsyBKUZyMWaZl6kPQ4Gzv74hNII0RS3qo3iDAO
+SojrO32zTQKBgQCBLLhEGZQIOX3D+9VRZ4r/xAHbtRHJ9wD0cG3c8Fz7+DI7YKk+
+Am3WfOtW4gZ/s/TKZNUE2qKV3q4R9T9iBlCdXk7gkLVXVXgVg48ZFgsrAGfWVmxr
+I7nkQQpQV0zdM1fC2w7oh9p6IJ1lmC9yyaYP/CKNtBcWXUXpuU+QCJYYlQKBgQDU
+PPtQmkvVYh54+wYHB014gcQQVNvXfbe3+Rta44r6jiFp/KYk9DVzI0taTxJvstdh
+y7vuiO+GtmteGVJKhfQPs/oYNpkT/ipCX0WHEoUZJppFD0LGdPD8BfCgoiybCKGt
+HFyYXVHKJHOy80OLScebJL1aN+xNTBFMTfXNPBOGCQKBgBEj1VaZXHxmQaDaDh6e
+nm/ZNAhIBJeM8LoDSUl/pTkW1AdD4scFxidq/pRsHijm0H9M9XxlCHOAyXQM6GOw
+ViRJgAU8wGhu/INMGjK5vBzeHhMCQAFJ/oBDbXK6P0Bz8fnmJIa6zbZlpVjc1czS
+bUoK0Dt/DbDBFAlBd1FkJu87
+-----END PRIVATE KEY-----
diff --git a/pkg/protocol/atmosphere/test_certs/server0.crt b/pkg/protocol/atmosphere/test_certs/server0.crt
new file mode 100644
index 0000000..15a5940
--- /dev/null
+++ b/pkg/protocol/atmosphere/test_certs/server0.crt
@@ -0,0 +1,85 @@
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 7 (0x7)
+    Signature Algorithm: sha1WithRSAEncryption
+        Issuer: DC=org, DC=simple, O=Simple Inc, OU=Simple Signing CA, CN=Simple Signing CA
+        Validity
+            Not Before: Feb 15 07:22:23 2018 GMT
+            Not After : Feb 15 07:22:23 2020 GMT
+        Subject: CN=127.0.0.1
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                Public-Key: (2048 bit)
+                Modulus:
+                    00:9a:f7:62:f0:80:21:4e:12:e0:1b:6e:39:fa:ee:
+                    fd:15:af:ba:1e:4c:d8:fe:c8:0a:8d:0b:40:5b:86:
+                    fc:68:8d:3f:b1:70:92:fd:f5:54:d5:54:4e:67:d1:
+                    7f:5e:7d:ef:ab:e2:3f:30:01:a9:ec:a7:e0:3e:9c:
+                    bf:57:d7:b7:38:a9:cb:58:04:3c:bb:64:3d:cd:b6:
+                    a0:e3:af:1e:82:f0:b0:44:0d:2a:20:eb:f0:ce:89:
+                    80:de:f1:70:46:1e:0a:48:6a:28:af:e0:32:28:f4:
+                    2b:aa:e4:d9:e7:6b:bf:0e:fc:00:16:49:35:65:78:
+                    6b:c4:4a:e8:dd:83:90:d5:36:33:2a:7d:89:f5:42:
+                    e9:0f:f9:26:35:eb:52:bd:99:23:23:97:b0:da:b9:
+                    24:bd:21:ef:ed:38:2b:77:80:70:26:d2:98:8b:4a:
+                    b7:73:5d:44:f7:8b:f4:03:77:4a:95:62:32:da:e4:
+                    fe:38:81:a6:ed:33:8a:e1:25:34:28:82:c0:e0:95:
+                    c4:3d:03:29:1b:79:96:db:40:c8:c5:6e:6e:26:e2:
+                    08:5b:99:d4:ed:11:a0:34:59:26:89:50:17:3f:0d:
+                    7e:c7:ed:38:4c:f0:85:6f:63:19:cc:1c:fe:63:37:
+                    2b:ac:9b:d3:f3:7b:9c:3c:ac:8a:17:46:39:5d:42:
+                    b1:31
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Key Usage: critical
+                Digital Signature, Key Encipherment
+            X509v3 Basic Constraints: 
+                CA:FALSE
+            X509v3 Extended Key Usage: 
+                TLS Web Server Authentication, TLS Web Client Authentication
+            X509v3 Subject Key Identifier: 
+                C2:00:37:62:4A:6D:DA:C8:1A:AC:88:B7:0D:C5:C8:BB:9C:A7:1B:BA
+            X509v3 Authority Key Identifier: 
+                keyid:83:1C:6A:53:0B:B4:76:15:9D:9A:8D:7B:39:2B:72:CD:A4:C0:69:E3
+
+            X509v3 Subject Alternative Name: 
+                IP Address:127.0.0.1
+    Signature Algorithm: sha1WithRSAEncryption
+         95:16:42:5d:b5:3e:0a:eb:75:ba:59:33:21:69:ba:d2:64:94:
+         3f:88:92:90:60:85:3e:f8:eb:8f:8e:15:c0:44:64:d9:95:e2:
+         ad:f2:da:71:c4:32:9f:94:86:13:a4:9b:b9:85:79:3e:76:8f:
+         51:61:1e:88:c1:cf:1a:4e:bb:c2:ba:c8:a7:3e:8b:cf:7c:22:
+         58:a7:b8:bd:93:2e:f9:10:74:81:1e:11:c9:74:19:f3:e7:41:
+         fe:98:f4:fa:bb:c9:97:fe:b8:0b:a3:93:7e:94:1d:5e:f7:b1:
+         19:3b:13:e0:c9:fe:5a:10:8c:5a:3c:75:59:0d:65:f3:ac:58:
+         6b:bb:29:d3:27:e1:40:94:e4:bd:fd:17:c7:11:20:3e:5d:66:
+         66:e4:a3:8a:f9:5e:5a:da:ee:71:91:1c:5a:05:e9:bc:19:a9:
+         88:9c:4a:41:27:3b:c4:d0:76:55:57:ee:c3:f4:04:57:a3:57:
+         08:0f:30:1e:e2:5c:90:c9:01:12:ed:e1:6a:05:3d:5f:94:57:
+         87:35:8b:c4:1a:7e:49:16:d6:1f:81:5c:15:5c:fa:13:58:22:
+         2e:4c:05:f0:1d:89:6c:32:a3:f4:cc:ce:20:4b:67:ea:38:3e:
+         b5:fb:77:00:0c:c5:4d:ac:9d:8c:8d:a1:fd:e1:ea:8e:c8:c0:
+         3c:af:78:fc
+-----BEGIN CERTIFICATE-----
+MIIDmDCCAoCgAwIBAgIBBzANBgkqhkiG9w0BAQUFADB6MRMwEQYKCZImiZPyLGQB
+GRYDb3JnMRYwFAYKCZImiZPyLGQBGRYGc2ltcGxlMRMwEQYDVQQKDApTaW1wbGUg
+SW5jMRowGAYDVQQLDBFTaW1wbGUgU2lnbmluZyBDQTEaMBgGA1UEAwwRU2ltcGxl
+IFNpZ25pbmcgQ0EwHhcNMTgwMjE1MDcyMjIzWhcNMjAwMjE1MDcyMjIzWjAUMRIw
+EAYDVQQDDAkxMjcuMC4wLjEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB
+AQCa92LwgCFOEuAbbjn67v0Vr7oeTNj+yAqNC0BbhvxojT+xcJL99VTVVE5n0X9e
+fe+r4j8wAansp+A+nL9X17c4qctYBDy7ZD3NtqDjrx6C8LBEDSog6/DOiYDe8XBG
+HgpIaiiv4DIo9Cuq5Nnna78O/AAWSTVleGvESujdg5DVNjMqfYn1QukP+SY161K9
+mSMjl7DauSS9Ie/tOCt3gHAm0piLSrdzXUT3i/QDd0qVYjLa5P44gabtM4rhJTQo
+gsDglcQ9AykbeZbbQMjFbm4m4ghbmdTtEaA0WSaJUBc/DX7H7ThM8IVvYxnMHP5j
+Nyusm9Pze5w8rIoXRjldQrExAgMBAAGjgY4wgYswDgYDVR0PAQH/BAQDAgWgMAkG
+A1UdEwQCMAAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQW
+BBTCADdiSm3ayBqsiLcNxci7nKcbujAfBgNVHSMEGDAWgBSDHGpTC7R2FZ2ajXs5
+K3LNpMBp4zAPBgNVHREECDAGhwR/AAABMA0GCSqGSIb3DQEBBQUAA4IBAQCVFkJd
+tT4K63W6WTMhabrSZJQ/iJKQYIU++OuPjhXARGTZleKt8tpxxDKflIYTpJu5hXk+
+do9RYR6Iwc8aTrvCusinPovPfCJYp7i9ky75EHSBHhHJdBnz50H+mPT6u8mX/rgL
+o5N+lB1e97EZOxPgyf5aEIxaPHVZDWXzrFhruynTJ+FAlOS9/RfHESA+XWZm5KOK
++V5a2u5xkRxaBem8GamInEpBJzvE0HZVV+7D9ARXo1cIDzAe4lyQyQES7eFqBT1f
+lFeHNYvEGn5JFtYfgVwVXPoTWCIuTAXwHYlsMqP0zM4gS2fqOD61+3cADMVNrJ2M
+jaH94eqOyMA8r3j8
+-----END CERTIFICATE-----
diff --git a/pkg/protocol/atmosphere/test_certs/server0.key b/pkg/protocol/atmosphere/test_certs/server0.key
new file mode 100644
index 0000000..511daf8
--- /dev/null
+++ b/pkg/protocol/atmosphere/test_certs/server0.key
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCa92LwgCFOEuAb
+bjn67v0Vr7oeTNj+yAqNC0BbhvxojT+xcJL99VTVVE5n0X9efe+r4j8wAansp+A+
+nL9X17c4qctYBDy7ZD3NtqDjrx6C8LBEDSog6/DOiYDe8XBGHgpIaiiv4DIo9Cuq
+5Nnna78O/AAWSTVleGvESujdg5DVNjMqfYn1QukP+SY161K9mSMjl7DauSS9Ie/t
+OCt3gHAm0piLSrdzXUT3i/QDd0qVYjLa5P44gabtM4rhJTQogsDglcQ9AykbeZbb
+QMjFbm4m4ghbmdTtEaA0WSaJUBc/DX7H7ThM8IVvYxnMHP5jNyusm9Pze5w8rIoX
+RjldQrExAgMBAAECggEAA+Ah+k/KBXDVZ/o2uv7VF4DAj9duKdkI4oQghOl4UIkP
+ybk+A9np2Df2igQkQlG19799ww6XmFKOeiJjaqf7bhBZBId+mVUlcoqZtXgAtFee
+oOUPY6li6VdpAKpbG3XO3gbBo7xgpMOOgASfKnl4WsCUo/oKutHrKAqTjk6nBZ3+
+bM4o6ajbHL1P+RLTXurVG2KcID0CcnOvyS4Eiw9ahv2SVNghYJLgS5UhzZpIWbO6
+QmDOdKpnVygE7FFgXl+gyv3PA4HbQtMwzXQD5uzuhWTlMIdNa4nxioDqkGOpSALs
+mt93agTTVWu3vZRTTZfpM9NkXVmwivvQuZgNWJZTfQKBgQDKrPFdaO5HF5uACKfu
+xuReFGY4WS+mm43VmDNQUVpKwc64nnXdvSP2DQxo6gGWfQaJETMX/CXjQA4NGNE+
+9EHZ1v+AKWZQtUSoFVWOOoeHeAZYmV7c38S+XFq8Ll+6lmXWr4tMIieGoBnMHzcD
+JGEYRE7abF6qCUKRfZ42Y9ZhVwKBgQDDvQbUU9MvO05jHB0NyRDrcuNzYBc1be+Y
+Po7RS/a6WUkEkMMChjur7239UV0ISRP6DfDe+ieYUs+SqOLsVxXEbAz4vgoPbcon
+rtSucmfYuyHh1JWRnUDXxw22N5qp3oJi7vryVstIfobRdKidstqjJVt4jYIs+vju
+2jLgWxhEtwKBgEQY/7AnBYiVggXu4p3z7d8+c2oTbVNJiMpvrS4bZ38ex1p4w5mR
+Z3fQwo6tsYLi10NOqCAy9Hf6mb4EzKmeYFHVT1u8jUgo37yqDmkPeWInDdrPDXSh
+KvXbChGYc0m6JtWPffpCr40oVgKjqlQ/8O+6Y9Q3/UacfeVsk7Aqs2lZAoGASPPo
+2bYsXcwy2QmfYoXwAnEdiODlhYpl5E5cmHFBkg65AjSaGhTBpMFmMyXiELZ79ZTA
+k7qUi1dB+h1sBj4m5MCIzSS3RyzaTZQBvMrzHXoRlMPQwybjBgkweRucT3eZDRqY
++T2UIn7V7LcYKT6B8pB32SSUwgMASLWWhLwu/V0CgYBSYK6ctdwyl9iZwNGNrp8U
+QgUfEZRJcBhRZQxH/3MpbYL3EDYJFj9Bl6VE3kJG+1N3IKcgkRIHHvLxJmieWrwV
+rG086NQkYQ3o0A6IE6gB9HMPHpq2l9x4eWCYPAFkfIe8aWnonThCTAJsmkTObvd5
+zryy5b1IMbfU+Uwd9ZeRjw==
+-----END PRIVATE KEY-----
diff --git a/pkg/protocol/atmosphere/transport.go b/pkg/protocol/atmosphere/transport.go
new file mode 100644
index 0000000..4702593
--- /dev/null
+++ b/pkg/protocol/atmosphere/transport.go
@@ -0,0 +1,163 @@
+package atmosphere
+
+import (
+	"crypto/tls"
+	"crypto/x509"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"net"
+)
+
+type (
+	TransportConfig struct {
+		// Tls specifies whether TLS 1.2 must be used or everything should be
+		// on top of pure TCP connection
+		Tls bool
+
+		// ClientAuthType specifies the client auth type
+		ClientAuthType tls.ClientAuthType
+
+		// KeyPemBlock contains data from private key PEM file.
+		KeyPemBlock []byte
+
+		// CertPemBlock contains data from certificate PEM file
+		CertPemBlock []byte
+
+		// RootPemBlock contains data from CA PEM file with certificates chain
+		RootPemBlock []byte
+	}
+
+	// tcp_server handles either TCP or TLS atmosphere connections
+	tcp_server struct {
+		ln  net.Listener
+		srv *server
+	}
+)
+
+// NewClient creates atmosphere client over pure TCP or TLS 1.2 transport
+func NewClient(srvAddrs string, ccfg *ClientConfig) (Writer, error) {
+	conn, err := getClientConn(srvAddrs, ccfg)
+	if err != nil {
+		return nil, err
+	}
+
+	return newClient(ccfg, conn), nil
+}
+
+// NewClient creates atmosphere server over pure TCP or TLS 1.2 transport
+func NewServer(scfg *ServerConfig) (io.Closer, error) {
+	srv := newServer(scfg)
+	ln, err := getServerListener(scfg)
+	if err != nil {
+		return nil, err
+	}
+
+	go func() {
+		defer srv.Close()
+		for {
+			conn, err := ln.Accept()
+			if err != nil {
+				break
+			}
+			err = srv.Serve(conn)
+			if err != nil {
+				break
+			}
+		}
+	}()
+	return &tcp_server{ln, srv}, nil
+}
+
+// LoadX509Files reads cert, key and CA chain PEM files and populates CertPemBlock,
+// KeyPemBlock and RootPemBlock accordingly. It will ignore data if the filename
+// is empty ("").
+func (tc *TransportConfig) LoadX509Files(cert, key, chain string) (err error) {
+	tc.CertPemBlock, err = readFile(cert)
+	if err != nil {
+		return err
+	}
+
+	tc.KeyPemBlock, err = readFile(key)
+	if err != nil {
+		return err
+	}
+
+	tc.RootPemBlock, err = readFile(chain)
+	return err
+}
+
+// readFile reads the file content and returns it as a slice of bytes, or
+// returns nil with error if any.
+func readFile(filename string) ([]byte, error) {
+	if len(filename) == 0 {
+		return nil, nil
+	}
+	return ioutil.ReadFile(filename)
+}
+
+func (tc *TransportConfig) getKeyPairCerts() ([]tls.Certificate, error) {
+	if len(tc.KeyPemBlock) != 0 && len(tc.CertPemBlock) != 0 {
+		cert, err := tls.X509KeyPair(tc.CertPemBlock, tc.KeyPemBlock)
+		if err != nil {
+			return []tls.Certificate{}, err
+		}
+		return []tls.Certificate{cert}, nil
+	}
+	return []tls.Certificate{}, nil
+}
+
+func (tc *TransportConfig) getRootCertPool() (*x509.CertPool, error) {
+	if len(tc.RootPemBlock) != 0 {
+		roots := x509.NewCertPool()
+		if !roots.AppendCertsFromPEM(tc.RootPemBlock) {
+			return nil, fmt.Errorf("Could not create Root Cert Pool, probably the CA certificates chain is incorrect")
+		}
+		return roots, nil
+	}
+	return x509.SystemCertPool()
+}
+
+func (tc *TransportConfig) getTlsConfig() (*tls.Config, error) {
+	kpCerts, err := tc.getKeyPairCerts()
+	if err != nil {
+		return nil, err
+	}
+
+	roots, err := tc.getRootCertPool()
+	if err != nil {
+		return nil, err
+	}
+
+	return &tls.Config{Certificates: kpCerts, RootCAs: roots, ClientAuth: tc.ClientAuthType, ClientCAs: roots}, nil
+}
+
+func (ts *tcp_server) Close() error {
+	return ts.ln.Close()
+}
+
+func getServerListener(scfg *ServerConfig) (net.Listener, error) {
+	if !scfg.Tls {
+		return net.Listen("tcp", scfg.ListenAddress)
+	}
+
+	tcfg, err := scfg.getTlsConfig()
+	if err != nil {
+		return nil, err
+	}
+
+	return tls.Listen("tcp", scfg.ListenAddress, tcfg)
+}
+
+func getClientConn(srvAddrs string, ccfg *ClientConfig) (net.Conn, error) {
+	if !ccfg.Tls {
+		return net.Dial("tcp", srvAddrs)
+	}
+
+	tcfg, err := ccfg.getTlsConfig()
+	if err != nil {
+		return nil, err
+	}
+
+	return tls.Dial("tcp", srvAddrs, tcfg)
+}
diff --git a/pkg/protocol/atmosphere/transport_test.go b/pkg/protocol/atmosphere/transport_test.go
new file mode 100644
index 0000000..7fd73b9
--- /dev/null
+++ b/pkg/protocol/atmosphere/transport_test.go
@@ -0,0 +1,103 @@
+package atmosphere
+
+import (
+	"bufio"
+	"crypto/tls"
+	"fmt"
+	"net"
+	"path/filepath"
+	"runtime"
+	"testing"
+)
+
+func runTestEchoSrv(ln net.Listener) {
+	for {
+		conn, err := ln.Accept()
+		if err != nil {
+			fmt.Println("Oops got the err=", err)
+			return
+		}
+		go handleTestEchoConn(conn)
+	}
+}
+
+func handleTestEchoConn(conn net.Conn) {
+	defer conn.Close()
+	r := bufio.NewReader(conn)
+	for {
+		msg, err := r.ReadString('\n')
+		if err != nil {
+			fmt.Println("handleTestEchoConn: Error while reading, err=", err)
+			return
+		}
+
+		n, err := conn.Write([]byte(msg))
+		if err != nil || n != len(msg) {
+			fmt.Println("handleTestEchoConn: Error while writing, err=", err)
+			return
+		}
+	}
+}
+
+func TestConnectivity(t *testing.T) {
+	cl, err := NewClient("127.0.0.1:12345", &ClientConfig{})
+	if cl != nil || err == nil {
+		t.Fatal("1) Expecting error for the connection")
+	}
+
+	scfg := &ServerConfig{ListenAddress: ":12345", Auth: func(aKey, sKey string) bool { return true }}
+	srv, err := NewServer(scfg)
+	if srv == nil || err != nil {
+		t.Fatal("should create srv ok")
+	}
+
+	cl, err = NewClient("127.0.0.1:12345", &ClientConfig{})
+	if cl == nil || err != nil {
+		t.Fatal("Expecting client be created ok")
+	}
+
+	srv.Close()
+	cl.Close()
+	cl, err = NewClient("127.0.0.1:12345", &ClientConfig{})
+	if cl != nil || err == nil {
+		t.Fatal("2) Expecting error for the connection")
+	}
+}
+
+func TestTlsMutual(t *testing.T) {
+	_, d, _, _ := runtime.Caller(0)
+	crtsDir := filepath.Dir(d) + "/test_certs/"
+	fmt.Println(crtsDir)
+
+	scfg := &ServerConfig{ListenAddress: ":12346"}
+	scfg.Tls = true
+	scfg.TransportConfig.LoadX509Files(crtsDir+"server0.crt", crtsDir+"server0.key", crtsDir+"chain.pem")
+	scfg.ClientAuthType = tls.RequireAndVerifyClientCert
+	ln, err := getServerListener(scfg)
+	if err != nil {
+		t.Fatal("Oops could not create server listener: err=", err)
+	}
+	defer ln.Close()
+
+	go runTestEchoSrv(ln)
+
+	ccfg := &ClientConfig{}
+	ccfg.Tls = true
+	ccfg.TransportConfig.LoadX509Files(crtsDir+"client0.crt", crtsDir+"client0.key", crtsDir+"chain.pem")
+	cc, err := getClientConn("127.0.0.1:12346", ccfg)
+	if err != nil {
+		t.Fatal("Oops could not create client listener: err=", err)
+	}
+
+	msg := "Hello TLS!\n"
+	n, err := cc.Write([]byte(msg))
+	if err != nil {
+		t.Fatal("Oops could not write to client, err=", err)
+	}
+
+	buf := make([]byte, 100)
+	n, err = cc.Read(buf)
+	if err != nil || len(msg) != n || string(buf[:n]) != msg {
+		t.Fatal("Oops could not read whatever we sent, err=", err, ", n=", n, ", msg=", msg, ", resp=", string(buf[:n]))
+	}
+}
diff --git a/pkg/util/hash/hash.go b/pkg/util/hash/hash.go
new file mode 100644
index 0000000..c68131d
--- /dev/null
+++ b/pkg/util/hash/hash.go
@@ -0,0 +1,130 @@
+package hash
+
+import (
+	"bytes"
+	"crypto/rand"
+	"crypto/sha256"
+	"encoding/base64"
+	"fmt"
+	"net"
+	"strings"
+)
+
+const (
+	secretKeyAlphabet = "0123456789QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnazx_^-()@#$%"
+	sessionAlphabet   = "0123456789QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnazx"
+)
+
+// GetMacAddress returns a non-loopback interface MAC address. It returns an
+// error with the reason, if it is not possible to discover one.
+func GetMacAddress() ([]byte, error) {
+	addrs, err := net.InterfaceAddrs()
+	if err != nil {
+		return nil, err
+	}
+
+	var ip string
+	for _, a := range addrs {
+		if ipn, ok := a.(*net.IPNet); ok && !ipn.IP.IsLoopback() {
+			if ipn.IP.To4() != nil {
+				ip = ipn.IP.String()
+				break
+			}
+		}
+	}
+	if ip == "" {
+		return nil, fmt.Errorf("could not find any ip address except loopback")
+	}
+
+	ifss, err := net.Interfaces()
+	if err != nil {
+		return nil, err
+	}
+
+	for _, ifs := range ifss {
+		if addrs, err := ifs.Addrs(); err == nil {
+			for _, addr := range addrs {
+				if strings.Contains(addr.String(), ip) {
+					nif, err := net.InterfaceByName(ifs.Name)
+					if err != nil {
+						continue
+					}
+
+					return []byte(nif.HardwareAddr), nil
+				}
+			}
+		}
+	}
+	return nil, fmt.Errorf("could not find any interface with MAC address")
+}
+
+// Makes a session with size characters in the the string. sessionAlphabet
+// is used for making the session
+func NewSession(size int) string {
+	return GetRandomString(size, sessionAlphabet)
+}
+
+// Makes a password string
+func NewPassword(size int) string {
+	return GetRandomString(size, secretKeyAlphabet)
+}
+
+func GetRandomString(size int, abc string) string {
+	var buffer bytes.Buffer
+	var val [64]byte
+	var buf []byte
+	if size > len(val) {
+		buf = make([]byte, size)
+	} else {
+		buf = val[:size]
+	}
+	Rand(buf)
+
+	for _, v := range buf {
+		buffer.WriteString(string(abc[int(v)%len(abc)]))
+	}
+
+	return buffer.String()
+}
+
+func Hash(str string) string {
+	return BytesHash([]byte(str))
+}
+
+func BytesHash(bts []byte) string {
+	h := sha256.Sum256(bts)
+	return base64.StdEncoding.EncodeToString(h[:])
+}
+
+func Rand(bts []byte) {
+	if _, err := rand.Read(bts); err != nil {
+		panic(err)
+	}
+}
+
+// Bytes2String transforms bitstream to a string. val contains bytes and
+// only lower bits from any value is used for the calculation. abet - is an
+// alpabet which is used for forming the result string.
+func Bytes2String(val []byte, abet string, bits int) string {
+	kap := len(val) * 8 / bits
+	abl := len(abet)
+	res := make([]byte, 0, kap)
+	mask := (1 << uint(bits)) - 1
+	i := 0
+	shft := 0
+	for i < len(val) {
+		b := int(val[i]) >> uint(shft)
+		bSize := 8 - shft
+		if bSize <= bits {
+			i++
+			if i < (len(val)) {
+				shft = bits - bSize
+				b |= int(val[i]) << uint(bSize)
+			}
+		} else {
+			shft += bits
+		}
+		res = append(res, abet[(b&mask)%abl])
+	}
+	return string(res)
+}
diff --git a/pkg/util/hash/hash_test.go b/pkg/util/hash/hash_test.go
new file mode 100644
index 0000000..6cfbecf
--- /dev/null
+++ b/pkg/util/hash/hash_test.go
@@ -0,0 +1,37 @@
+package hash
+
+import (
+	"net"
+	"testing"
+)
+
+func TestNewSession(t *testing.T) {
+	for i := 0; i < 100; i++ {
+		s := NewSession(i)
+		if len(s) != i {
+			t.Fatal("Unexpected length ", len(s), ", but wanted ", i)
+		}
+		t.Log(s)
+	}
+}
+
+func TestNewPassword(t *testing.T) {
+	for i := 0; i < 100; i++ {
+		s := NewPassword(i)
+		if len(s) != i {
+			t.Fatal("Unexpected length ", len(s), ", but wanted ", i)
+		}
+		t.Log(s)
+	}
+}
+
+func TestGetMacAddress(t *testing.T) {
+	mac, err := GetMacAddress()
+	if err != nil {
+		t.Log("Could not find mac. err=", err)
+		return
+	}
+
+	ms, _ := net.ParseMAC(string(net.HardwareAddr(mac).String()))
+	t.Log("mac= ", ms, " ", mac)
+}
-- 
2.14.3 (Apple Git-98)

